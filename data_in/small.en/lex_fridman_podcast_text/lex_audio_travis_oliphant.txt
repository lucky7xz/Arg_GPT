 The following is a conversation with Travis Oliphant, one of the most impactful programmers and data scientists ever. He created NumPy, SciPy, and Anaconda. NumPy formed the foundation of Tensor-based machine learning in Python. SciPy formed the foundation of scientific programming in Python, and Anaconda, specifically with Conda, made Python more accessible to a much larger audience. Travis's life work across a large number of programming and entrepreneurial efforts has and will continue to have immeasurable impact on millions of lives by empowering scientists and engineers in big companies, small companies, and open source communities to take on difficult problems and solve them with the power of programming. Plus, he's a truly kind human being, which is something that when combined with vision and ambition makes for a great leader and a great person to chat with. To support this podcast, please check out our sponsors in the description. As usual, I'll do a few minutes of ads now, no ads in the middle. I try to make these interesting, so hopefully you don't skip, but if you do, please still check out the sponsor links in the description. It does happen to be the best way to support this podcast. I use this stuff. I enjoy it. Maybe you will too. This show is brought to you by Novo, which is a business banking app. The process is simple. You sign up, they'll mail you a Novo debit card, and you get free ATM use. Honestly, if there's any industry that needs disruption, it's the old school banking industry, and that's exactly what Novo does. It's backed by FDIC insurance, like the old school banks, but there's no hidden fees, no monthly fees, or minimum balance requirements. It has an easy to use mobile app. You can apply in under 10 minutes. There's always human powered customer service. I like the way that sounds, human powered. Free transfers, mailed checks, and incoming wires. Integrates with other small business tools, like Stripe, Shopify, QuickBooks, and many more. Refunds all the ATM fees, like I said. Thousands of dollars in exclusive perks. Go to banknova.com slash Lex to sign up for free. That's banknova.com slash Lex. I highly encourage you go there and support the disruption of the old school banking industry. This show is also sponsored by Allform, a furniture company. They ship to your home quickly, take it back for free if you don't like it in the first 100 days. It's easy to assemble, looks beautiful and classy, and it feels amazing. I love it. I have one of their love seat. It's a leather, it's black. It looks gorgeous, it feels great. I hung out with a lot of interesting people on that love seat. There's something about the dynamics of a love seat. You do have a little bit of space between you, but you're just close enough to where you have to contend with the challenges of human intimacy. For example, I hung out with Michael Malice on that love seat, although he specifically refuses to acknowledge the emergent humanity in this particular computer's soul. Anyway, go to allform.com slash Lex. They're offering 20% off all orders. If you go to allform.com slash Lex, there's small couches there, big ones, and it's beautiful and it feels great. This episode is also brought to you by Onnit, nutrition, supplement, and fitness company. They make Alpha Brain, which is a nootropic that helps support memory, mental speed, and focus. I take it when I have a difficult, deep work session coming up, and I really need help to get my mind to that place of clarity, of focus. I don't like to over-caffeinate myself and get jittery. I like what Alpha Brain does. It's like a steady focus that I get from it. I don't use it every day, so it's not part of my ritual. It's more like a jetpack, a super boost, that I use when I know the session's going to be difficult, mentally challenging. Obviously, I first heard about Onnit on the Joe Rogan experience, so it feels surreal to be doing an ad-read for them now, but I've really enjoyed their stuff for a long time, so I'm proud and happy. Anyway, go to lexfeedman.com slash Onnit to get up to 10% off Alpha Brain. That's lexfeedman.com slash Onnit. This show is also brought to you by Athletic Greens, and it's new, renamed AG1 Drink, which is an all-in-one daily drink to support better health and peak performance. It replaced the multivitamin for me and went far beyond that with 75 vitamins and minerals. There's so much good stuff in there. It tastes delicious. It's now like an integral part of my day. I drink it now at least twice a day. I make sure that I get the nutritional base for all the crazy things I do in terms of athletic pursuits, in terms of long sessions of deep work, and also having a keto or mostly a carnivore diet. So get the nutrition that my mind, my body needs, given all the diet, given all the hard work I have to undertake. Anyway, they will give you one-month supply of fish oil when you sign up at athleticgreens.com slash Lex. That's athleticgreens.com slash Lex. This episode is also brought to you by Blinkist, my favorite app for learning new things. Blinkist takes the key ideas from thousands of nonfiction books and condenses them down into just 15 minutes that you can read or listen to. I love reading slowly, reading through the whole book, and thinking deeply through every page, through every paragraph. But couple that, I also love using Blinkist to pick which books I'm going to read next, and using Blinkist to review the key insights from the books I've already read. So because I read so slowly and so deeply, I can't possibly afford to read a large number of books. So I rely on Blinkist to help me remember the key insights from books and to help pick future books. Go to Blinkist.com slash Lex to start your free seven day trial and get 25% off of a Blinkist premium membership. That's Blinkist.com slash Lex. This is the Lex Friedman podcast, and here is my conversation with Travis Olyphant. What was the first computer program you've ever written? Do you remember? Whoa, that's a good question. I think it was in fourth grade. Just a simple loop in basic. Basic. Basic, yeah, on an Atari 400, I think, or maybe an Atari 800. It was a part of a class, and we just were just basic loops to print things out. Did you use go-to statements? Yes, yes, we used go-to statements. I remember in the early days, that's when I first realized there's like principles to programming when I was told that, don't use go-to statements. Those are bad software engineering prints. It goes against what great, beautiful code is. I was like, oh, okay, there's rules to this game. I didn't see that until high school when I took an AP computer science course. I did a lot of other kinds of just programming in TI, but finally when I took an AP computer science course in Pascal. Wow. Yeah, it was Pascal. That's when I, oh, there are these principles. Not C or C++? No, I didn't take C until the next year in college. I had a course in C, but I haven't done much in Pascal. Just that AP computer science course. Now, sorry for the romanticized question, but when did you first fall in love with programming? Oh man, good question. I think actually when I was 10, my dad got us a TI Timex Sinclair and he was excited about the spreadsheet capability. And then, but I made him get the basic, the add-on so we could actually program in basic and just being able to write instructions and have the computer do something. And we got a TI 99 and a TI 99 4A when I was about 12. Now it just, it has sprites and graphics and music. You could actually program it to do music. That's when I really sort of fell in love with programming. So this is a full, like a real computer with like, with memory and storage and processors or whatnot, because you say TI, it's not- Yeah, the Timex Sinclair was one of the very first, it was a cheap, cheap, like I think it was, well, it was still expensive, but it was 2K of memory. We got the 16K add-on pack, but yeah, it had memory and you could program it. You had to, in order to store your programs, you had to attach a tape drive. Remember that old, the sound that would play when you converted the modem, so it would convert digital bits to audio files instead of a tape drive. Still remember that sound, but that was the storage. And what was the programming language, do you remember? It was basic. It was basic. And then they had a VisiCalc. And so a little bit of spreadsheet programming in VisiCalc, but mostly just some basic. Do you remember what kind of things drew you to programming? Was it working with data? Was it video games? Math. Games, math. Mathy stuff. Yeah, I've always loved math. And a lot of people think they don't like math because I think when they're exposed to it early, it's about memory. When you're exposed to math early, you have a good short-term memory and key members' timetables. And I do have a reasonably, I mean, not perfect, but a reasonably long little short-term memory buffer. And so I did great at timetables. I said, oh, I got good at math. But I started to really like math, just the problem-solving aspect. And so computing was problem-solving applied. And so that's always kind of been the draw and coupled with the mathematics. Did you ever see the computer as like an extension of your mind, like something able to achieve? Not till later. Okay. Yeah, not then. It's just like a little set of puzzles that you can play with and you can, you can play with math puzzles. Yeah, it was too rudimentary early on. Like it was sort of, yeah, it was a lot of work to actually take a thought you'd have and actually get it implemented. And that's still work, but it's getting easier. And so, yeah, I would say that's definitely what's attracted me to Python is that that was more real, right? I could think in Python. Speaking of foreign language, I only speak another language fluently, besides English, which is Spanish. And I remember the day when I would dream in Spanish and you start to think in that language. And then you actually, I do definitely believe that language limits or expands your thinking. There's some languages that actually lead you to certain thought processes. Yeah, like, so I speak Russian fluently and that's certainly a language that leads you down certain thoughts. Is that right? Well, yeah, I mean, there's a history of the two world wars of millions of people starving to death and years of death throughout its history of suffering, of injustice, like this promise sold to the people and then the carpet or whatever swept from under them. And it's like broken promises and all of that pain and melancholy is in the language. The sad songs, the sad, hopeful songs, the over romanticized, like, I love you, I hate you, the sort of the swings between all the various spectrums of emotion. So that's all within the language. The way it's twisted, there's a strong culture of rhyming poetry. So like the bards, like the sink, there's a musicality to the language too. Did Dostoyevsky write in Russian? Yeah, so like Dostoyevsky, all the, all the. The ones that I know about, which are translated and I'm curious how the translations. So Dostoyevsky did not use the musicality of the language too much. So it actually translates pretty well because it's so philosophically dense that the story does a lot of the work, but there's a bunch of things that are untranslatable. Certainly the poetry is not translatable. I actually have a few conversations coming up offline and also on this podcast with people who've translated Dostoyevsky. And that's for people who worked, who work in this field know how difficult that is. Sometimes you can spend, you know, months thinking about a single sentence in context, like, because there's just a magic captured by that sentence and how do you translate just in the right way? Because those words can be really powerful. There's a famous line, beauty will save the world from Dostoyevsky. You know, there's so many ways to translate that. And you're right, the language gives you the tools with which to tell the story, but it also leads your mind down certain trajectories and paths to where over time, as you think in that language, you become a different human being. Yes. Yeah. Yeah, that's a fascinating reality, I think. I know people have explored that, but it's, I guess, we rediscovered. Well, we don't, we live in our own little pockets. Like, this is the sad thing is I feel like, unfortunately, given time and getting older, I'll never know China, the Chinese world, because I don't truly know the language. Same with Japanese, I don't truly know Japanese and Portuguese and Brazil, that whole South American continent, like, yeah, I'll go to Brazil and Argentina, but will I truly understand the people if I don't understand the language? And it's sad because I wonder how many geniuses we're missing because so much of the scientific world, so much of the technical world is in English, and so much of it might be lost because they're, it's just, we don't have the common language. I completely agree. I'm very much in that vein of, there's a lot of genius out there that we miss, and it's sort of fortunate when it bubbles up into something that we can understand or process, there's a lot we miss. So that's why I tend to lean towards really loving democratization or things that empower people, or very resistant to authoritarian structures. Fundamentally for that reason, well, several reasons, but it just hurts us, we're soft. So speaking of languages that empower you, so Python was the first language for me that I really enjoyed thinking in, as you said. Sounds like you shared my experience too. So when did you first, do you remember when you first kind of connected with Python, maybe you even fell in love with Python? It's a good question. It was a process, it took about a year. I first encountered Python in 1997. I was a graduate student studying biomedical engineering at the Mayo Clinic, and I had previously, I'd been involved in taking information from satellites, so I was an electrical engineering student, used to taking information and trying to get something out of it, doing some data processing and information out of it. And I'd done that in Matlab, I'd done that in Perl, I'd done that in scripting on a VMS, there's actually a VAX VMS system, they had their own little scripting tools around FORTRAN. Done a lot of that, and then as a graduate student, I was looking for something and encountered Python, and because Python had an array, it had two things that made me not filter it away. Because I was filtering a bunch of stuff, it was Yorick, I looked at Yorick, I looked at a few other languages throughout there at the time in 1997, but it had arrays, there's a library called numeric that had just been written in 95, like not too much earlier, by an MIT alum, Jim Huginan, and I went back and read the mailing list to see the history of how it grew, and it was very interesting, it's fascinating to do that actually, to see how this emergent cooperation, unstructured cooperation happens in the open source world, that led to a lot of this collective programming, which is something maybe we might get into a little later, about what that looks like. What gap did numeric fill? Numeric fill the gap of having an array object, so instead of- There was no array object. There was no array, there was a one dimensional byte concept, but there was no n dimensional, two, three, four dimensional tensor, they call it now, I'm still in the category that a tensor is another thing, and it's just an nd array, we should call it, but kind of lost that battle. And- There's many battles in this world, some of which will win, some will lose. That's exactly right. So, but it had no math to it. So numeric had math, and a basic way to think in arrays. So I was looking for that, and it had complex numbers. A lot of programming languages, and you can see it, because if you're just a computer scientist, you think, ah, complex numbers just too float, so people can build that on. But in practice, a complex number, as one of the significant algebras that helps connect a lot of physical and mathematical ideas, particularly to FFT for an electrical engineer. And it's a really important concept, and not having it means you have to develop it several times, and those times may not share an approach. One of the common things in programming, one of the things programming enables is abstractions. But when you have shared abstractions, it's even better. It sort of gets to the level of language of, actually, we all think of this the same way, which is both powerful and dangerous, right? Because powerful in that we now can quickly make bigger and higher level things on top of those abstractions dangerous because it also limits us to the things we left, maybe left behind in producing an abstraction, which is at the heart of programming today and actually building around the programming world. I think it's a fascinating philosophical topic. Yeah, they will continue for many years, I think. They will continue for many years. As we build more and more and more abstractions. Yes, I often think about, you know, we have a world that's built on these abstractions that were they the only ones possible? Certainly not, but they led to, you know, it's very hard to do it differently. Like there's an inertia that's very hard to, you know, push out, push away from. That has implications for things like, you know, the Julia language, which you have heard of, I'm sure. And I've met the creators and I like Julia. It's a really cool language, but they've struggled to kind of against just the tide of like this inertia of people using Python. And, you know, there's strategies to approach that, but nonetheless, it's a phenomenon. And sometimes, so I love complex numbers and I love to race, so I looked at Python. And then I had the experience, I did some stuff in Python and I was just doing my PhD. So I was out, my focus was on, I was actually doing a combination of MRI and ultrasound and looking at a phenomenon called elastography, which is you push waves into the body and observe those waves, like you can actually measure them. And then you do mathematical inversion to see what the elasticity is. And so that's the problem I was solving is how to do that with both ultrasound and MRI. I needed some tool to do that with. So I was starting to do this Python in 1997. In 98, I went back, looked at what I'd written and realized I could still understand it, which is not the experience I've had when doing Pearl in 95. Right, I'd done the same thing and then I looked back and I'd forgotten what it was even saying. Now, you know, I'm not saying it, so I, that, that may, hey, this may work, I like this. This is something I can retain without becoming an expert per se. And so that led me to go, I'm gonna push more to this. And then that 98 was kind of the, when I started to fall in love with Python, I would say. A few peculiar things about Python. So maybe compared to Pearl, compared to some of the other languages. So there's no braces. Yeah. So you, space is used, indentation I should say is used as part of the language. Yeah, right. So did you, I mean, that's quite a leap. Were you comfortable with that leap or were you just very open-minded? It's a good question. I was open-minded, so I was cognizant of the concern. And it definitely has, it has specific challenges. You know, cut and pasting, for example, when you're cutting pasting code, and if your editors aren't supportive of that, or you're put into a terminal, and particularly in the past when terminals didn't necessarily have the intelligence to manage it now. Now, I Python and Jupyter Notebooks handle that just fine, so there's really no problem. But in the past, it created some challenges, formatting challenges, also mixed tabs and spaces. If editors weren't, you weren't clear on what was happening, you would have these issues. So there were really concrete reasons about it that I heard and understood. I never really encountered a problem with it, personally. Like it was occasional annoyances, but I really liked the fact that it didn't have all this extra characters, right? That these extra characters didn't show up in my visual field when I was just trying to process understanding a snippet of code. Yeah, there's a cleanness to it. But I mean, the idea is supposed to be that Perl also has a cleanness to it because of the minimalism of like how many characters it takes to express a certain thing. So it's very compact. But when you realize that that compactness comes, there's a culture that prizes compactness. And so the code gets more and more compact and less and less readable to a point where it's like, like to be a good programmer in Perl, you write code that's basically unreadable. There's a culture like- Correct, and you're proud of it. Yeah, you're proud of it. Right, exactly. And it's like feels good. And it's really selective. Like it means you have to be an expert in Perl to understand it. Whereas Python was allowed you not to have to be an expert. You didn't have to take all this brain energy. You could leverage what I say, you could leverage your English language center, which you're using all the time. I've wondered about other languages, particularly non-Latin based languages. Latin based languages with the characters are really similar. I think people have an easier time, but I don't know what it's like to be a Japanese or a Chinese person trying to learn a different syntax. Like what would computer programming look like in that? I haven't looked at that at all, but it certainly doesn't, leveraging your Chinese language center, I'm not sure Python or any programming does that. But that was a big deal. The fact that it was accessible, I could be a scientist. What I really liked is many programming languages really demand a lot of you and you can get a lot, you do a lot if you learn it. But Python enables you to do a lot without demanding a lot of you. There's nuance to that statement, but it certainly is more accessible. So more people could actually, as a scientist, as somebody who, or engineer, who was trying to solve another problem besides point programming, I could still use this language and get things done and be happy about it. I was also comfortable in C at that time. And Matlab you did a little bit of that. And Matlab I did a lot before that, exactly. So I was comfortable in, those three languages were really the tools I used during my studies and schooling. But to your point about language helping you think, one of the big things about Matlab is it was, and APL before it, I don't know if you remember APL. APL is actually the predecessor of array-based programming, which I think is really an underappreciated, if I talked to people who were just steeped in computer programming, computer science, like most of the people that Microsoft has hired in the past, for example, Microsoft as a company generally did not understand array-based programming, like culturally, they didn't understand it. So they kept missing the boat, kept missing the understanding of what this was. They've gotten better, but there's still a whole culture of folks that doesn't program. That's, you know, that's systems programming or web programming or lists and maps. And what about an n-dimensional array? Oh yeah, that's just an implementation detail. Well, you can think that, but then actually if you have that as a construct, you actually think differently. APL was the first language to understand that and it was in the sixties, right? The challenge of APL is APL had very dense, not only glyphs, like new characters, new glyphs, they even had a new keyboard because to produce those glyphs, this was back in the early days of computing when, you know, the QWERTY keyboard maybe wasn't as established. Like, well, we could have a new keyboard, no big deal. But it was a big deal and it didn't catch on. And the language APL, very much like Pearl, as people would pride themselves on how much, could they write the game of life in 30 characters of APL? APL has characters that mean summation and they have adverbs, you know, they have adjectives and these things called adverbs, which are like methods, like reduction, it would be an adverb on an ad operator. Right? So, but using these tools, you could construct and then you start to think at that level. You think in n-dimensions is something I like to say and you start to think differently about data at that point. You know, now you're, it really helps. Yeah, I mean, outside of programming, if you really internalize linear algebra as a course, I mean, it's philosophically allows you to think of the world differently. It's almost like liberating. You don't have to think about the individual numbers in the n-dimensional array. You could think of it as an object in itself and all of a sudden this world can open up. You're saying MATLAB and APL word, like the early C, I don't know if many languages got that right ever. No, no, no, they didn't. Even still. Even still, I would say. I mean, NumPy is a, as an inheritor of the traditions. I would say APLJ was another version that was, what it did is not have the glyphs, just have short characters, but still a Latin keyboard could type them. And then numeric inherited from that in terms of, let's add arrays plus broadcasting plus methods, reduction, even some of the language like rank is a concept that's in, that was in Python, is still in Python for the number of dimensions, right? That's different than say the rank of a matrix, which people think of as well. So it came from that tradition, but NumPy is a very pragmatic practical tool. NumPy inherited from numeric and we can get to where NumPy came from, which is the current array, at least current as of 2015, 2017. Now there's a ton of them over the past two or three years. We can get into that too. So if we just sort of linger on the early days of what was your favorite feature of Python? Do you remember like what, it's so interesting to linger on like the, what really makes you connect with a language? I'm not sure it's obvious to introspect that. No, it isn't. And I've thought about that to some length. I think definitely the fact that I could read it later, that I could use it productively without becoming an expert. Other languages I had to put more effort into. That's like an empirical observation. Like you're not analyzing any one aspect of the language. It just seems time after time, when you look back, it's somehow readable. It's somehow readable. Then it was sort of, I could take executable English and translate it to Python more easily. Like I didn't have to go, there was no translation layer. As an engineer or as a scientist, I could think about what I wanted to do. And then the syntax wasn't that far behind it. Yeah. Right. Now there were some, there were some warts there still. It wasn't perfect. Like there's some areas where like, it'd be better if this were different or if this were different. Some of those things got out of the language too. I was really grateful for some of the early pioneers in the Python ecosystem back. Cause Python got written in 91, is when the first version came out. But Guido was very open to users. And one of the sets of users were people like Jim Huguenin and David Asher and Paul Dubois and Conrad Hinson. These were people that were on the main list. And they were just asking for things like, hey, we really should have complex numbers in this language. So let's, you know, there's a J there's a one J right. And the fact that they went the engineering route of J is interesting. I don't think that's entirely favorite engineers. I think it's because I is so often used as the index of a for loop. I think that's actually why. Probably. I mean, there's a pragmatic aspect. The fact that complex numbers were there. I love that. The fact that I could write ndarrays constructs and that reduction was there. Very simple to write summations and broadcasting was there. I could do addition of whole arrays. So that was cool. Those are some things I loved about it. I don't know what to start talking to you about because you've been you've created so many incredible projects that basically changed the whole landscape of programming. But okay, let's start with let's go chronologically with Sci-Fi. You create a Sci-Fi over two decades ago now. Yes. Right. Yes. I love to talk about Sci-Fi. Sci-Fi was really my baby. What is it? Yeah. What was its goal? How does it work? Yeah. Fantastic. So Sci-Fi was effectively here. I'm using Python to do stuff that I previously use MATLAB to use. And I was using numeric, which is an array library that made a lot of it possible. But I know there's things that were missing. Like I didn't have an ordinary differential equation solver. I could just call, right? I didn't have integration. Yeah. I wanted to integrate this function. Okay. Well, I don't have just a function I can call to do that. These are things I remember being critical things that I was missing optimization. I just want to pass a function to an optimizer and have it tell me what the optimal value is. Those are things like, well, why don't we just write a library that adds these tools? And I started to post on the main list and there previously been people have discussed and remember Conrad Henson saying, wouldn't it be great if we had this optimizer library or David Ash would say this stuff. And I'm ambitious, ambitious is the wrong word, and eager and probably more time than sense. I was a poor graduate student. My wife thinks I'm working on my PhD and I am, but part of a PhD that I loved was the fact that it's exploratory. You're not just taking orders, fulfilling a list of things to do. You're trying to figure out what to do. And so I thought, well, I'm writing tools for my own use in a PhD. So I'll just start this project. And so in 99, 98 was when I first started to write libraries for Python. But when I fell in love with Python 98, I thought, oh, well, there's just a few things missing. Like, oh, I need a reader to read DICOM files. That was in medical imaging and DICOM was a format that I wouldn't be able to load that into Python. Okay, how do I write a reader for that? So I wrote something called, it was an IO package, right? And that was my very first extension module, which is C. So I wrote C code to extend Python so that in Python, I could write things more easily. That combination kind of hooked me. It was the idea that I could, here's this powerful tool I can use as a scripting language and a high level language to think about, but that I can extend easily. Easily in C, that easily for me because I knew enough C. And then Guido had written a link. I mean, the only, the hard part of extending Python was something called the way memory management works. And you have to reference counting. And so there's a tracking of reference counting you have to do manually. And if you don't, you have memory leaks. And so that's hard. Plus then C, it's much more, you have to put more effort into it. It's not just, I have to now think about pointers and I have to think about stuff that is different. I have to kind of, you're like putting a new cartridge in your brain. Like you're, okay, I'm thinking about MRI. Now I'm thinking about programming. And there are distinct modules you end up having to think about. So it's harder. And when I was just in Python, I could just think about MRI and high level writing. But I could do that and that kind of, I liked it. I found that to be enjoyable and fun. And so I ended up, oh, well, let me just add a bunch of stuff to Python to do integration. Well, and the cool thing is, is that the power of the internet, I just looking around and I found out there's this net live, which has hundreds of 4chan routines that people have written in the sixties and the seventies and the eighties and 4chan 77 fortunately, it wasn't 4chan 16. So I've been my ported to 4chan 77. And 4chan 77 is actually a really great language. 4chan 90 probably is my favorite 4chan because it's got complex numbers, got arrays and it's pretty high level. Now the problem with it is you'd never want to write a program in 4chan 90 or 4chan 77. But it's totally fine to write a subroutine in. And so, and then 4chan kind of got a little off course when they tried to compete with C++. But at the time, I just want libraries to do something like, oh, here's an ordinary differential equation. Here's integration, here's rung cut integration. Already done, I don't have to think about that algorithm. I mean, you could, but it's nice to have somebody who's already done one and tested it. And so I sort of started this journey in 98 really, look back at the manual list, there's sort of this productive era of me writing an extension module to connect rung cut integration to Python and making an ordinary additional equation solver. And then releasing that as a package. So we could call ODE pack, I think I called it then, quad pack, and then I just made these packages. Eventually that became multi-pack because they're originally modular, you can install them separately, but a massive problem in Python was actually just getting your stuff installed. At the time, releasing software for me, like today it's people think, what does that mean? Well, then it meant some poorly written webpage, I had some bad webpage up and I put a tarball, just a Gzip tarball of source code. That was the release. But okay, can we just stand that? Sure. Because that, the community aspect of creating the package and sharing that. Yes. That's rare. That to have, to both have the, at that time, so like the raw- Yeah, it was pretty early, yeah. So, oh well, not rare. Maybe you can correct me on this, but it seems like in the scientific community, so many people, you were basically solving the problems you needed to solve to process the particular application, the data that you need. And to also have the mind that I'm going to make this usable for others. That's- I would say I was inspired. I'd been inspired by Linux, been inspired by Linus and him making his code available. And I was starting to use Linux at the time and I went, this is cool. So I'd kind of been previously primed that way. And generally I was into science because I liked the sharing notion. I liked the idea of, hey, let's, if collectively we build knowledge and share it, we can all be better off. Okay, so you want to energize by that idea. So it was energized by that idea already. Yeah. Right? And I can't deny that I was. I'm sort of had this very, I liked that part of science, that part of sharing. And then all of a sudden, oh wait, here's something. And here's something I could do. And then I slowly over years learned how to share better so that you could actually engage more people faster. One of the key things was actually giving people a binary they could install. Right? So that wasn't just your source code. Good luck. Compile this and then. It's compiled ready to install. You just, you know, so a lot of the journey from 98, even through 2012, we used to, when I started Anaconda was about that. Like it's why, you know, it's really the key as to why a scientist with dreams of doing MRI research ended up starting a software company that installs software. I work with a few folks now that don't program like on the creative side and the video side, the audio side. And because my whole life is running on scripts, I have to try to get them, I'm having all the task of teaching them how to do Python enough to run the scripts. And so I've been actually facing this whether it's on the Condor, some, with the task of how do I minimally explain, basically to my mom, how to write a Python script. And it's an interesting challenge. I have to, it's a to-do item for me to figure out like, what is the minimal amount of information I have to teach? What are the tools you use? That one, you enjoy it to your effect of it. And they're related. Those are two related questions. And then the debugging, like the iterative process of running the script to figure out what the error is, maybe even for some people to do the fix yourself. So do you compile it? Do you distribute, like how do you distribute that code to them? And it's interesting because I think it's exactly what you're talking about. If you increase the circle of empathy, the circle of people that are able to use your programs, you increase its effectiveness and its power. And so you have to think, can I write scripts? Can I write programs that can be used by biomedical engineers, by all kinds of people that don't know programming? And actually maybe plant a seed, have them catch the bug of programming so that they start on their journey. And that's a huge responsibility. And ultimately it has to do with the Amazon one click by. Like how frictionless can you make the early steps? Frictionless is actually really key. To grow in any community is any friction point, you're just gonna lose some people. Now, sometimes you may wanna intentionally do that. If you're early enough on, you need a lot of help. You need people who have the skills. You might actually, it's helpful. You don't necessarily have too many users as opposed to contributors if you're early on. Anyway, there's a, Sci-Fi started in 98, but it really emerged as this collection of modules that I was just putting on the net, people were downloading. And I think I got a hundred users by the end of that year. But the fact that I got a hundred users and more than that, people started to email me with fixes. And that was actually intoxicating. That was the, here I'm writing papers, I'm giving conferences and I get people to say hello, but yeah, good job. But mostly it was, you're reviewed with, it's competitive. You publish a paper and people are like, oh, it wasn't my paper. I was starting to see that sense of academic life where it was so much, I thought there was a cooperative effort, but it sounds like we're here just to one up each other. And it's not true across the board, but a lot of that's there. But here in this world, I was getting responses from people all over the world. I remember Piero Peterson in Estonia, was one of the first people. And he sent me back this make file. Because the first thing it is, you're building stinks and here's a better make file. Now it was a complex make file. I don't think I never understood that make file actually, but it worked and it did a lot more. And so I was like, thanks, this is cool. And that was my first kind of engagement with community development. But the process was, he sent me a patch file. I had to upload a new tar ball. And I just found, I really love that. And the style back then was here's a main list. It wasn't as, it certainly weren't the tools that are available today. It was very early on. But I really started to, that's the whole year. I think I did about seven packages that year. And then by the end of the year, I collected them into a thing called Multi-Pack. So 99, there was this thing called Multi-Pack. And that's when a high school student, no he was a high school student at the time, guy named Robert Kern, took that package and made a Windows installer. And then of course a massive increase of usage. So by the way, most of this development was under Linux. Yes, yes, it was on Linux. I was a Linux developer doing it on the Unix box. I mean, at the time I was actually getting into, I had a new hard drive, we did some kernel programming to make the hard drive work. I mean, not programming, but modification to the kernel so I could actually get a hard drive working. I love that aspect of it. I was also in, at school I was building a cluster. I took Mac computers and you put Yellow Dog Linux on them. They were at the Mayo Clinic, they were just, all these Macs that were older, they were just getting rid of. And so I kind of got permission to go grab them together. I put about 24 of them together in a cluster, in a cabinet and put Yellow Dog Linux on them all. And I wrote a C++ program to do MRI simulation. That was what I was doing at the same time for my day job, so to speak. So I was loving the whole process. At the same time I was, oh, I need a ordinary differential equation. That's why ordinary differential equations were key was because that's the heart of a block equation for simulating MRI is an ODE solver. And so that's, but I actually did that, it doesn't happen at the same time. That's why it kind of what you're working on and what you're interested in, they're coinciding. I was definitely scratching my own itch in terms of building stuff. And which helped in the sense that I was using it for me. So at least I had one user. I had one person who was like, well, no, this is better. I like this interface better. And I had the experience of MATLAB to guide some of what those APIs might look like. But you're just doing yourself, you're building all this stuff. But the Windows installer, it was the first time I realized, oh yeah, the binary installer really helps people. And so that led to spending more time on that side of things. So around 2000, so I graduated my PhD in 2000, end of 2000, so 99 doing a lot of work there, 98 doing a lot of work there, 99 kind of spending more time on my PhD, helping people use the tools, thinking about what do I want to go from here? There was a company, there was a guy actually, Eric Jones and Travis Vaught. They were two friends who founded a company called Enthot. It's here in Austin, still here. And they, Eric contacted me at the time when I was a graduate student still. And he said, hey, why don't you come down, we want to build a company. You know, we're thinking of a scientific company and we want to take what you're doing and kind of add it to some stuff that he'd done. He'd written some tools. And then PR Peterson had done F2PY. Let's come together and build, pull this all together and call it SciPy. So that's the origin of the SciPy brand. It came from, you know, Multipack and a whole bunch of modules I'd written plus a few things from some other folks and then pulled together in a single installer. SciPy was really a distribution of Python, mass green is a library. How did you think about SciPy in context of Python, in context of numeric? Like what- So we saw SciPy as a way to make an R&D environment for Python, like use Python dependent on numeric. So numeric was the array library we depended on. And then from there extend it with a bunch of modules that allowed for, and at the time, the original vision of SciPy was to have plotting, was to have, you know, the REPL environment and kind of a whole, really a whole data environment that you could then install and get going with. And that was kind of the thinking. It didn't really evolve that way, right? It sort of had a, for one, it's really hard to do massive scale projects with open source collectives. Actually there's sort of an intrinsic cooperation limit as to which too many cooks in the kitchen, you can do amazing infrastructure work. When it comes down to bringing it all together into a single deliverable, that actually requires a little more product management that is not, that doesn't really emerge from the same dynamic. So it struggled, it struggled to get, almost too many voices, it's hard to have everybody agree, consensus doesn't really work at that scale. You end up with politics, with the same kind of things that's happened in large organizations trying to decide on what to do together. So consensus building was still, was challenging at scale as more people came in, right? Early on, it's fine, because there's nobody there. So it works, but then as you get more successful and more people use it, all of a sudden, oh, there's this scale at which this doesn't work anymore and we have to come up with different approaches. So Sci-Fi came out officially in 2001, was the first release, most of the time. I remember the days of getting that release ready, it was a Windows installer and there was, there were bugs on how the Windows compiler handled complex numbers and you were chasing segmentation faults. And it was, it's a lot of work. There's a lot of effort had nothing to do with my area of study. And at the same time, I had just gotten an offer. So he wondered if I wanted to come down and help him start that company with his friend. And at the time I was like, I was intrigued, but I was squaring a path, an academic path. And I had just got an offer to go and teach at my album otter. So I took that tenure track position. And Sci-Fi, and kind of, then I started working on Sci-Fi as a professor too. Okay. So that's, I left, I've got to my clinic graduate, wrote my thesis using Sci-Fi, wrote, you know, there's images that were created. Now the plotting tool I use was something from Yorick, actually, it was a plotting PLT, kind of a plotting language that I used. The Yorick is a programming language? It was a programming language, had a plotting tool, Dislin, it had integration to Dislin. I ended up using Dislin plus some of the plotting from Yorick, linked to from Python. Anyway, it was a, people don't plot that way now. This is before, and Sci-Fi was trying to add plotting. Yeah. Right? It didn't have much success. Really the success of plotting came from John Hunter, who had a similar experience to my experience, my kind of maverick experience as a person just trying to get stuff done and kind of having more time than money maybe. Right? And John Hunter created what? Mapplotlib. He's a creator of Mapplotlib. Yeah. So John Hunter was a, you know, he wasn't a student at the time, but he was an actor, he was working in Quantfield and he said, we need better plotting. So he just went out and said, cool, I'll make a new project and we'll call it Mapplotlib. And he released in 2001, about the same time that Sci-Fi came out. And it was separate library, separate install, use numeric, Sci-Fi use numeric. And so Sci-Fi, you know, 2001 we released Sci-Fi and then Enthok created a conference called Sci-Fi, which was brought people together to talk about the space. And that conference is still ongoing. It's one of the favorite conferences of a lot of people because it's, you know, it's changed over the years, but early on it was, you know, a collection of 50 people who care about scientists mostly, practicing scientists who want to care about coding and doing it well and not using Matlab. And I remember being driven by, you know, I liked Matlab, but I didn't like the fact that, so I'm not opposed to proprietary software. I'm actually not an open source zealot. I love open source for the, what it brings, but I also see the role for proprietary software. But what I didn't like was the fact that I would develop code and publish it and then effectively telling somebody here to run my code, you have to have this proprietary software. Right, and there's also culture around Matlab as much, because I've talked to a few folks in, MathWorks, Grids, Matlab. Yeah, I mean, there's just a culture, they try really hard, but it just, there's this corporate IBM style culture that's like, or whatever, I don't want to say negative things about IBM or whatever, but there's a- No, it's really that connection. It's something I'm in the middle of right now, is the business of open source and how do you connect the ethos of cooperative development with the necessity of creating profits, right? And like right now today, I'm still in the middle of that. That's actually the early days of me exploring this question. Because I was writing Sci-Fi, I mean, as an aside, I also had, so I had three kids at the time. I have six kids now. I got married early, wanted a family. I had three kids and I remember reading, I remember I read Richard Stallman's post and I was a fan of Stallman. I would read his work. I liked this collective ideas he would have. Certainly the ideas on IP law, I read a lot of stuff. But then he said, okay, well, how do I make money with this? How do I make a living? How do I pay for my kids? All this stuff was in my mind. Young graduate student making no money, thinking I gotta get a job. And he said, well, I think just be like me and don't have kids, right? That's just don't- That's his take on that. That was what he said in that moment, right? That's the thing I read and I went, okay, this is a train I can't get on. There has to be a way to preserve the culture of open source and still be able to make sufficient money to feed you. Yes, exactly. There's gotta be, well, so that actually led me to a study of economics. Because at the time I was ignorant and it really was. I'm actually, I'm embarrassed for educational system that they could let me, and I was valedictorian in my high school class and I did super well in college. And academically I did great, right? But the fact that I could do that and then be clueless about this key part of life, it led me to go, there's a problem. Like I should have learned this in fifth grade. I should have learned this in eighth grade. Like everybody should come out with a basic knowledge of economics. You're an interesting example because you've created tools that change the lives of probably millions of people and the fact that you don't understand it at the time of the creation of those tools, the basics economics of how to build up giant system is the problem. Yeah, it's a problem. And so during my PhD at the same time, this is back in 98, 99 at the same time, I was in a library, I was reading books on capitalism, I was reading books on Marxism, I was reading books on, what is this thing? What does it mean? And I encountered a, basically what I, I encountered a set of writings from people that said they were the inheritors of Adam Smith. But Adam Smith for the first time, right? Which is the wealth of nations and kind of this notion of emergent, emergent societies and realized, oh, there's this whole world out here of people. And the challenge of economics is also political. Like, because economics, people, different parties running for office, they want their economic friends, they want their economists to back them up, right? Or to be their magicians, like the magicians in Pharaoh's court, right? The people that are kind of say, hey, this is, you should listen to me because I've got the expert who says this. And so it gets really muddled, right? I was looking at it from a, as a scientist going, what does this space, what does this mean? How does Paris get fed? How does money, how does it work? And I found a lot of writings that I really loved. I found some things that I really loved. And I learned from that. It was writings from people like Von Miss S. He wrote a Peabody paper in 1920 that still should be read more than it is. It was the economic calculation problem of the socialist Commonwealth. It was basically in response to the Bolshevik Revolution in 1917. And his basic argument was, it's not gonna work to not have private property. You're not gonna be able to come up with prices. The bureaucrats aren't gonna be able to determine how to allocate resources without a price system. And a price system emerges from people making trades. And they can only make trades if they have authority over the thing they're trading. And that creates information flow that you just don't have if you try to top down it. Right. Right. And it's like, huh, that's a really good point. Yeah, the prices have a signal that's used. And it's important to have that signal when you're trying to build a community of productive people like you would in the software engineering space. Yeah, the prices are actually an important signaling mechanism. Yeah. Right. And that money is just a bartering tool. Yeah. Right. So this is the first time I've encountered any of this concept, right? And the fact that, oh, this is actually really critical. Like it's so critical to our prosperity and that we're dangerously not learning about this, not teaching our children about this, you know. So you had the three kids, they had to make some hard decisions. Had to make some money, right? Had to figure it out. But I didn't really care. I mean, I've never been driven by money, just need it. Yeah. Right. And it's a thing to eat. So how did that resolve itself in terms of side by? So I would say it didn't really resolve itself. It sort of started a journey that I'm continuing on. I'm still on, I would say. I don't think it resolved itself, but I will say I went in eyes wide open. Like I knew that there were problems with, you know, giving stuff away and creating the market externalities, that the fact that, yeah, people might use it and I might not get paid for it and I'll have to figure something else out to get paid. Like at least I can say I'm not bitter that a lot of people have used stuff that I've written and I haven't necessarily benefited economically from it. Like I've heard other people be bitter about that when they write or they talk, like, oh, I should have got more value out of this. And I'm also, I want to create systems that let people like me who might have these desires to do things, let them benefit. So that actually creates more of the same. Not to turn on your bitterness module, but there's some aspect, I wish there's mechanisms for me to reward whoever created Sci-Fi and NumPy. Cause it brought so much joy into my life. I appreciate that. And I mean, the tip dark notion was there. I appreciate that. But there should be a very, very shameless mechanism. I totally agree. I would love to talk about some of the ideas I have. Cause I actually came across, I think I've come up with some interesting notions that could work, but they'll require, you know, anything that will work takes time to emerge. Right? Like things don't just turn over. That's definitely one thing I've also understood and learned is any fixes. That's why it's kind of funny. We often give credit to, you know, all this president gets elected and oh, look how great things have done. And I saw that when I had a transition in a condo, when a new CEO came in, right? And it's like the success that's happening, there's an inertia there. Yeah. Right. And sometimes the decision made like 10 years before is the reason why the success is the- Right, exactly. So we're sort of just one around taking credit for stuff. The credit assignment has like a delay to it. Yes. That makes the credit assignment basically wrong more than right. Wrong more than right. Exactly. And so I'm like, oh, this is, you know, that's the stuff I would read a ton about, you know, early on. So I don't, I feel like I'm with you. Like I want the same thing. I want to be able to, and honestly, not for personally, I've been happy. I've been happy. I feel like I don't have any, I mean, we've been done reasonably okay, but I've had to pursue it. Like that's really what started my trajectory from academia is reading that stuff, let me say, oh, entrepreneurship matters. I love software, but we need more entrepreneurs and I want to understand that better. So once I kind of had that virus infect my brain, even though I was on a trajectory to go to a tenure track position at a university and I was there for six years, I was kind of already out the door when I started. And we can get into that, but. What can I just ask a quick question on, is there some design principles that were in your mind around Sci-Fi? Like, was there some key ideas that were just like sticking to you that this is the fundamental ideas? Yeah, I would say so. I would think it's basically accessibility to scientists. Like give scientists and engineers tools that they don't have to think a lot about programming. So give them really good building blocks, give them functions that they want to call and sort of just the right length of spelling. There's one tradition in programming where it's like, make very, very long names, right? And you can see it in some programming languages where the names get ticked off the screen. And in the 4chan world, characters had to be six letters early on, right? And that's way too much, too little, but I was like, I like to have names that were informative, but short. So even though Python, well, this is a different conversation, but documentation is doing some work there. So when you look at great scientific libraries and functions, there's a richness of documentation that helps you get into the details. The first glance at a function gives you the intuition of all it needs to do by looking at the headers and so on, but to get the depths of all the complexities involved, all the options involved, documentation does some work. Documentation is essential. So that was actually, so we thought about several things. One is we wanted plotting, we wanted interactive environment, we wanted good documentation. These are things we knew, we wanted. The reality is those took about 10 years to evolve, right? Given the fact that we didn't have a big budget, it was all volunteer labor. It was sort of, when N-Thought got created and they started to try to find projects people would pay for pieces and they were able to fund some of it, not nearly enough to keep up with what was necessary. And no criticism, just simply the reality. I mean, it's hard to start a business and then do consulting and then also promote an open source project that's still fairly new, cyber was fairly niche. We stayed connected all while I was a student, sorry, a professor. I went to BYU and started to teach electrical engineering, all the applied math courses. I loved teaching single processing, probability theory, electrical magnetism. I was the, if you look at Ray, my professor, which my kids love to do, I wasn't, I got some bad reviews because people- What was the criticism? I would speak to high, too high of a level. Like I definitely had a calibration problem coming out of graduate work where I hate to be condescending to people. Like I really have a ton of respect for people fundamentally. Like my fundamental thing is I respect people. Sometimes that can lead to a, I was thinking they had more knowledge than they did. And so I would just speak at a very high level, assume they got it. But they need to rise to the standard that you set. I mean, that's one of the, some of the greatest teachers do that. And I agree. And that was kind of what was inspiring me, but you also have to, I cannot say I was articulate with some of the greatest teachers, right? I was, like one classic example, when I first taught at BYU, my very first class, it was overheads, transparency is overheads. Before projectors were really that common. So transparency is I'm writing my notes out. I go in, room's half dark. I just blaring through these transparencies. Here it is, here it is, here it is. And I gave a quiz after two weeks. Nowhere knew anything. Nothing I had taught had gotten anywhere. And I realized, okay, I'm not, this is not working. So I put away the transparencies and I turned around and just started using the chalkboard. And what it did is it slowed me down, right? The chalkboard just slowed me down and gave people time to process and to think. And then that made me focused. My writing wasn't great on their chalkboard, but I really loved that part of like the teaching. So that entered Sci-Fi's world in terms of, we always understood that there's a didactic aspect of Sci-Fi, kind of how do you take the knowledge and then produce it? The challenge we had was the scope. Like ultimately Sci-Fi was everything, right? And so 2001 when it first came out, people were starting to use it. No, this is cool. This was a tool we actually use. At the same time, 2001 timeframe, there was a little bit of like the Hubble Space Telescope, the folks at Hubble had started to say, Hey, Python, we're gonna use Python for processing images from Hubble. And so Perry Greenfield was a good friend and running that program. And he had called me before I left to BYU and said, you know, we wanna do this, but numeric actually has some challenges in terms of, you know, it's not, the array doesn't have enough types. We need more operations. You know, broadcast needs to be a little more settled. They wanted record arrays. They want to, you know, record arrays are like a data frame, but a little bit different, but they want a more structured data. So he had called me even early on then and they said, you know, what, would you want to work on something to make this work? And I said, yeah, I'm interested, but I'm going here and I, you know, we'll see if I have time. So in the meantime, while I was teaching and Sci-Fi was emerging and I had a student, I was constantly while I was teaching, trying to figure a way to fund this stuff. So I had a graduate student, my only graduate student, a Chinese fellow, Liu Hongze is his name, great guy. He wrote a bunch of stuff for iterative, iterative linear algebra, like got into writing some of the iterative, linear algebra tools that are currently there in Sci-Fi and they've gotten better since, but this is in 2005, kept working on Sci-Fi. But Perry has started working on a replacement to numeric called nummera. And in 2004, a package called ndimage, it was an image processing library that was written for nummera. And it had in it a morphology tool. I don't know what morphology is, it's open, dilation, you know, there was sort of this, as a medical imaging student, I knew what it was because it was used in segmentation a lot. And in fact, I'd wanted to do something like that in Python and Sci-Fi, but just had never gotten around to it. So when it came out that it worked only on nummera and Sci-Fi needed numeric. And so we effectively had the beginning of this split and numeric and nummera didn't share data. They were just too, so you could have a gigabyte of numeric, nummera data and gigabyte of numeric data and they wouldn't share it. And so you had these, then you had these scientific libraries written on top. I got really bugged by that. I got really like, oh man, this is not good. We're not cooperating now. We're not, we're sort of redoing each other's work and we're just this young community. So that's what led me, even though I knew it was risky because my, you know, I was on a tenure track position, 2004, I got reviewed. They said, hey, things are going okay, you're doing well, paper's coming out, but you're kind of spending a lot of time in this open source stuff, maybe do a little less of that and a little more of the paper writing and grant writing, which was naive, but it was definitely the tie, you know, the thinking. Still goes on. Still goes on. You're basically creating a thing which enables science in the 21st century. Right. Maybe don't emphasize that so much in your free year tenure. Right. It illustrates some of the challenges. Yes. It does. And it's, people mean well, like, but we've gotten broken in a bunch of ways. Certain things, programming, understanding the role of software engineering, programming, society is a little bit laggy. Exactly. Now I was in an electrical engineering position. Right. That's even worse. There. Yeah, it was very, they were very focused. And so, you know, good people, and I had a great time. I loved my time, I loved my teaching, I loved all the things I did there. The problem was the split was happening in this community I loved. I saw people, and I went, oh my gosh, this is gonna be, this is not great. And so I happened, you know, fate, I had a class I had signed up for, I was trying to build an MRI system, so I had a kind of a radio, instead of a radio, a digital radio class, it was a digital MRI class. And I had people sign up, two people signed up, then they dropped, and so I had nobody in this class. So, and I didn't have any other courses to teach, and I thought, oh, I've got some time, and I'll just write a merger of numeric and numeric. Like, I'll basically take the numeric code base at the features numeric was adding, and then kind of come up with a single array library that everybody can use. So that's where NumPy came from, was my thinking, hey, I can do this, and who else is going to? Because at that point, I'd been around the community long enough, and I'd written enough C code, I knew the structures. And I, in fact, my first contribution to numeric had been writing the CAPI documentation that went in the first documentation for NumPy, for numeric, sorry. This is Paul Dubois, David Asher, Conrad Hinson, and myself. I got credit because I wrote this chapter, which is all the CAPI of numeric, all the C stuff. So I said, probably the one to do it, nobody else is going to do this. So it's sort of out of a sense of duty and passion, knowing that, I don't think my academic, I don't think the department here is going to appreciate this, but it's the right thing to do. It was like- Can we just link on that moment? Yeah, yeah. Because the importance of the way you thought and the action you took, I feel is understated and is rare. And I would love to see so much more of it, because what happens as the tools become more popular, there's a split that happens. And it's a truly heroic and impactful action to in those early, in that early split, to step up and it's like great leaders throughout history, like get, what is the Brave Heart? Like get on a horse and rile the troops, because I think that can have make a big difference. We have TensorFlow versus PyTorch in the machine learning community. We have the same problem today. Yeah, I wonder- It's actually bigger. I wonder if it's possible in the early days to rally the troops. It is possible, especially in the early days. The longer it goes, the harder, right? And the more energy in the factions, the harder. But in the early days, it is possible and it's extremely helpful. And there's a willingness there, but the challenge is there's usually not a willingness to fund it. There's not a willingness to, you know, like I was literally walking into a field saying I'm gonna do this. And here I am, I have five kids at home now. Pressure builds. Sometimes my wife hears these stories and she's like, you did what? I thought you were actually on a path to make sure we had resources and money, but. But again, there's an aspect, I'm a very hopeful person. I'm an optimistic person of my nature. I love people. I learned that about myself later on. Part of my, my religious beliefs actually lead to that. And it's why I hold them dear, because it's actually how I feel about, that's what leads me to these attitudes, sort of this hopefulness and this sense of, yeah, it may not work out for me financially, but that's not the ultimate gain. Like that's a thing, but that's not the scorecard for me. And so I just wanted to be helpful. And I knew, and partly because these Sci-Fi conferences, because of the mailing list conversations, I knew there was a lot of need for this, right? And so I had this, it wasn't like I was alone in terms of no feedback. I had these people who knew, but it was crazy. Like people who, at the time said, yeah, we didn't think you'd be able to do it. We thought it was crazy. And also instructive, like practically speaking, that you had a cool feature that you were chasing in the morphology. Like the, it's not just like. There's an end result. It's not some visionary thing. I'm going to unite the community. You were like. Correct. You were actually practically, this is what one person actually could do and actually build them. Because that is important. Because you can get over your skis. Yeah. You can definitely get over your skis. And I had, in fact, this almost got me over my skis, right? I would say, well, in retrospect, I hate looking back. I can tell you all the flaws with NumPy, right? When I go into it, there's lots of stuff that I'm like, oh man, that's embarrassing. That was wrong. I wish I had somebody slap me with a wet fish there. Like I needed, like what I'd wished I'd had was somebody with more experience and certainly library writing and array library. There's like, I wish I had me. I could go back in time and go do this, do that. There's important being. Because there's things we did that are still there that are problematic, that created challenges for later. And I didn't know it at the time. Didn't understand how important that was. And in many cases, didn't know what to do. Like there was pieces of the design of NumPy. I didn't know what to do until five years ago. Now I know what they should have been to Ben, but I didn't know at the time and nobody, and I couldn't get the help. Anyway, so I wrote it. It took about, it took four months to write the first version, then about 14 months to make it usable. But it was, it wasn't, it was that first four months of intense writing, coding, getting something out the door that worked. That was, it was, it was definitely challenging. And then the big thing I did was create a new type object called D type. That was probably the sync, the contribution. And then the fact that I added broad, not just broadcasting, but advanced indexing so that you could do masked indexing and indirect indexing instead of just slicing. So for people who don't know, and maybe you can elaborate. NumPy, I guess the vision in the narrowest sense is to have this object that represents n-dimensional arrays. And like at any level of abstraction you want, but basically it could be a black box that you can investigate in ways that you would naturally want to investigate such objects. Yes, exactly. So you could do math on it easily. So it had an associated library of math operations. And effectively, SciPy became an even larger operate set of live math operations. So the key for me was I was going to write NumPy and then move SciPy to depend on NumPy. In fact, early on, one of the initial proposals was that we would just write SciPy and it would have the numeric object inside it. And it'd be SciPy dot array or something. That turned out to be problematic because numeric already had a little mini library of linear algebra and some functions and it had enough momentum, enough users that nobody wanted to, they wanted backward compatibility. One of the big challenges of NumPy was I had to be backward compatible with both numeric and NumArray in order to allow both of those communities to come together. There was a ton of work in creating that backward compatibility that also created echoes in today's object. Like some of the complexity in today's object is actually from that goal of backward compatibility to these other communities, which if you didn't have that, you'd do something different, which is instructive because a lot of things are there. You know, what is that there for? It's like, well, it's a remnant. It's an artifact of its historical existence. By the way, I love the empathy and the lack of ego behind that because I feel you see that in the split in the JavaScript frameworks, for example, the arbitrary branching. Right. I think in order to unite people, you have to kind of put your ego aside and truly listen to others. You do. What do you love about NumArray? What do you love about numeric? Like actually get a sense. We're talking about languages earlier, sort of empathize to the culture, the people that love something about this particular API, some, the naming style or the use, they actually usage patterns and like truly understand them. And so that you can like create that same draw in the United. I completely agree. And you have to also have enough passion that you'll do it. It can't be just like a perfunctory, oh yes, I'm really, I listened to you. And then I'm not really excited about it. So it really is an aspect. It's a philosophical, like there's a filia. There's a love of a steaming of others. It's actually at the heart of what, it's sort of a life philosophy for me, right? That I'm constantly pursuing. That helped, absolutely helped. Makes me wonder in a philosophical, like looking at human civilization as one object, it makes me wonder how we can copy and paste Travis's in this stuff. Well, some aspects maybe. Some aspects, right, right, exactly. Well, it's like- It's a good question. How do we teach this? How do we encourage it? How we lift it? Because so much of the software world, it's giant communities, right? But it seems like so much is moved by like little individuals. You talk about like Linus Torvald. It's like, can you, could you have not, could you have had Linux without him? Could you, it's like- Yeah, Gido and Python. Wait, Gido and Python. Gido and Python. I mean, the SciPy community particularly, it's like I said, we wanted to build this big thing, but ultimately we didn't. What happened is we had Mavericks and champions like John Hunter who created Matplotlib. We had Fernando Perez who created IPython. And so we sort of inspired each other, but there's sort of a culture of this selfless, the stewardship mentality, as opposed to ownership mentality, but stewardship and community focused, community focused but intentional work. Like not waiting for everybody else to do the work, but you're doing it for the benefit of others and not worried about what you're gonna get. You're not worried about the credit, you're not worried about what you're gonna get, you're worried about, I later realized that I have to worry a little about credit, not because I want the credit, because I want people to understand what led to the results. Like I don't, it's not about me, is I wanna understand this is what led to the result. So let's like, I think doing, and this is what had no impact on the result. Like let's promote, this is just like you said, I wanna promote the attributes that helped make us better off. How do we make more of Wes McKinney? Like Wes McKinney was critical to the success of Python because of his creation of pandas, which is the roots of that were all the way back in numeric and num array and numpy, where numpy created an array of records. Wes started to use that almost like a data frame, except it's an array of records. And data frame, the challenge is, okay, if you wanna augment it at another column, you have to insert, you have to do all this memory movement to insert a column. Whereas data frames became, oh, I'm gonna have a loose collection of arrays. So it's a record of arrays that is the heart of a data frame. And we thought about that back in the memory days, but Wes ended up doing the work to build it. And then also the operations that were relevant for data processing. What I noticed is just that each of these little things creates just another tick, another up. So numpy ultimately took a little while, about six months in, people started to join me. Francesc Altad, Robert Kern, Charles Harris. And these people are many of the unsung heroes, I would say, people who are, they sometimes don't get the credit they deserve, because they were critical both to support, like, it's hard and you need some support, people need support. And I needed just encouragement. And they were helping and encouraged by contributing. And once the big thing for me was when John Hunter, he had previously done kind of a simple thing called numeric to kind of move between numeric and number A, get a little high level tool that would just select each one for Matplotlib. In 2006, he finally said, we're gonna just make numpy the dependency of Matplotlib. As soon as he did that, and I remember specifically when he did that, I said, okay, we've done it. Like, that was when I knew he had success. Before then it was still, you know, I didn't do unsure, but that kind of started a roller coaster. And then 2006 to 2009, and then I've been floored by what it's done. Like, I knew it would help. I had no idea how much it would help, right? And it has to do with, again, the language thing, it just, people started to think in terms of numpy. Like, and that opened up a whole new way of thinking. And part of the story that you kind of mentioned, but maybe you can elaborate, it seems like at some point in this story, Python took over science and data science. And bigger than that, the scientific community started to think like programmers or started to utilize the tools of computers to do, like at a scale that wasn't done with Fortran, like at this gigantic scale, they started to opening their heart. And then Python was the thing. I mean, there's a few other competitors, I guess, but Python, I think really, really took over. I agree. There's a lot of stories here that are kind of during this journey because this is sort of the start of this journey in 2005, six. So my tenure committee, I applied for tenure in 2006, 2007. It came back, I split the department. I was very polarizing. I had some huge fans. And then some people said, no way, right? So it was very, I was a polarizing figure in the department. It went all the way up to the university president. Ultimately, my department chair had the sway and they didn't say no. They said, come back in two years and do it again. And I went, at that point, I was like, I had this interest in entrepreneurship, this interest in not the academic circles, not the like, how do we make industry work? So I do have to give credit to that exploration of economics because that led me, oh, I had a lot of opinions. I was actually very libertarian at the time. And I still have some libertarian trends, but I'm more of a, I'm more of a collectivist libertarian. So you value broadly, philosophically freedom. I value broadly, philosophically freedom, but I also understand the power of communities, like the power of collective behavior. And so what's that balance, right? That makes sense. So by the time I was just, I got to go out and explore this entrepreneurial world. So I left academia. I said, no, thanks. Called my friend, Eric here, who had, his company was going. I said, hey, could I join you and start this trend? And he, at that time they were using Sci-Fi a lot. They were trying to get clients. And so I came down to Texas and in Texas is where I sort of, it's my entrepreneurial world, right? I left academia and went to entrepreneur world in 2007. So I moved here in 2007, kind of took a leap, knew nothing really about business, knew nothing about a lot of stuff there. There's, you know, for a long time, I've kept some connections to a lot of academics because I still value it. I still love the scientific tradition. I still value the essence and the soul and the heart of what is possible. Don't like a lot of the administration and the kind of, we can go into detail about why and where and how this happens and what are the challenges. I don't know, but I'm with you. So I'm still affiliated with MIT. I still love MIT because there's magic there. Yeah. There's people I talk to like researchers, faculty, in those conversations and the whiteboard and just the conversation, that's magic there. All the other stuff, the administration, all that kind of stuff seems to, you don't want to say too harshly criticized sort of bureaucracies, but there's a lag that seems to get in the way of the magic. And I don't, I'm still have a lot of hope that that can change because I don't often see that particular type of magic elsewhere in the industry. So like we need that and we need that flame going. And it's the same thing as exactly as you said, it has the same kind of elements like the open source community does. And, but then if you, like the reason I stepped away, the reason I'm here just like you did in Austin is like, if I want to build one robot, I'll stay at MIT. But if I want to build millions and make money enough to where I can explore the magic of that, then you can't. And I think that dance is- That translational dance has been lost a bit, right? And there's a lot of reasons for that. I'm certainly not an expert on this stuff. I can opine like anybody else, but I realized that I wanted to explore entrepreneurship which I, and really figure out, and it's been a driving passion for 20 years, 25 years. How do we connect capital markets and company? Cause again, I fell in love with the notion, oh, profit seeking on its own is not a bad thing. It's actually a coordination mechanism for allocating resources that, you know, in an emergent way, right? That respects everybody's opinions, right? So this is actually powerful. So I say all the time when I make a company and we do something that makes a profit, what we're saying is, hey, we're collecting of the world's resources and voluntarily people are asking us to do something that they like. And that's a huge deal. And so I really liked that energy. So that's what I came to do and to learn and to try to figure out. And that's what I've been kind of stumbling through since for the past 14 years. And that's 2007. 2007, yeah. And so you were still working on that part. So NOPI was just emerging, right? Just emerging. One of the things I've done, it's worth mentioning because it's emphasized the exploratory nature of my thinking at the time. I said, well, I don't know how to fund this thing. I've got a graduate student I'm paying for and I've got no funding for him. And I had done some fundraising from the public to try to get public fundraisers from my lab. I didn't really want to go out and just do the fundraising circuit the way it's traditionally done. So I wrote a book and I said, I'm gonna write a book and I'm gonna charge for it. It was called Guide to NOPI. And so ultimately NOPI became documentation driven development because I basically wrote the book and made sure the stuff worked or the book would work. So it really helped actually make NOPI become a thing. So writing that book, and it was not a page turner. Guide to NOPI is not a book you pick up and go, oh, this is great over the fire. But it's where you could find the details. Like how'd all this work? And a lot of people love that book. And so a lot of people ended up, so I said, look, I need to, so I'm gonna charge for it. And I got some flack for that, not that much. Just probably five angry messages, people's yelling at me saying I was bad guy for charging for this book. Was one of them which is Tom? No. Just kidding. No, I haven't really had any interaction with him personally, like I said, but there were a few, but actually surprisingly not. There was actually a lot of people like, no, it's fine, you can charge for a book. That's no big deal. We know that's a way you can try to make money around open source. So what I did, I did an interesting way. I said, well, kind of my ideas around IP law and stuff. I love the idea you can share something, you can spread it. Like once it's the fact that you have a thing and copying is free, but the creation is not free. So how do you fund the creation and allow the copying? And then software is a little more complicated than that because creation is actually a continuous thing. It's not like you build a widget and it's done. It's sort of a process of emerging and continuing to create. But I wrote the book and had this market determined price thing. I said, look, I need, I think I said 250,000. If I make 250,000 from this book, I'll make it free. So as soon as I get that much money, or I said five years, right? So there's a time limit, like that forever. I didn't know the story, it's amazing. I released it on this. And it's actually interesting because one of the people who also thought that was interesting ended up being Chris White, who was the director of DARPA project that we got funding through at Anaconda. And the reason he even called us back is because he remembered my name from this book and he thought that was interesting. And so even though we hadn't gone to the demo days, we applied and the people said, yeah, nobody ever gets this without coming to the demo day first. This is the first time I've seen it. But it's because I knew Chris had done this and had this interaction. So it did have impact. I was actually really, really pleased by the result. I mean, I ended up in three years, I mean, 90,000. So sold 30,000 copies by myself. I just put it up on, you know, use PayPal and sold it. And those are my first tastes of kind of, okay, this can work to some degree. And I, you know, all over the world, right? From Germany to Japan, it was actually, it did work. And so I appreciated the fact that PayPal existed and I had a way to make, to get the money, the distribution was simple. This is pre Amazon book stuff. So it was just publishing a website. It was the popularity of Sci-Fi emerging and getting company usage. I ended up not letting it go the five years and not trying to make the full amount because, you know, a year and a half later, I was at Enthot. I had left academia as an Enthot and I kind of had a full-time job. And then actually what happened is the documentation people, there was a group that said, hey, we want to do the documentation for Sci-Fi as a collective. And they were essentially needing the stuff in the book. And so they kind of asked, hey, can we just use the stuff in your book? And at that point I said, yeah, I'll just open it up. So that's, but it has served its purpose. And the money that I made actually funded my grad student. Like it was actually, you know, I paid him 25,000 a year out of that money. So- The funny thing is if you do very similar kind of experiment now with NumPy or something like it, you could probably make a lot more. That's probably true. Because of the tooling and the community building. Yeah, I agree. And social media, there's just a virality to that kind of idea. I agree. There'd be things to do. I've thought about that. And really I've thought about a couple of books or a couple of things that could be done there. And I just haven't, right? I tried to hire a ghost writer this year too to see if that could help, but it didn't. But part of my problem is this, I've been so excited by a number of things that sent them from that. Like, so I came here, worked at Entho for four years. Graciously, you know, Eric made me president and we started to work closely together. We actually helped them buy out his partner. It didn't end great. Like, unfortunately, Eric and I aren't real, aren't friends now. I still respect him and have a lot, I wish we were, but he didn't like the fact that Peter and I started Anaconda, right? That was not, I mean, so there's two sides to that story. So I'm not gonna go into it, right? Sure. But you, as human beings and you wish you still could be friends. I do, I do. It saddens me. I mean, that's a story of great minds building great companies. Somehow it's sad that when there's that kind of. And I hold him in esteem, I'm grateful for him. I think he's, they're doing, Entho still exists, they're doing great work. Helping scientists, they still run the Sci-Fi conference. They're in the, they have an R&D platform they're selling now that's a tool that you can go get today, right? So they've been, Entho has played a role in the Sci-Fi, in supporting the community around Sci-Fi, I would say. They ended up not being able to, they ended up building a tool suite to write GUI applications. Like that's where they could actually make that the business could work. And so the supporting Sci-Fi and NumPy itself wasn't as possible. Like they didn't, they try. I mean, it was not just because, it was just because of the business aspect. So, and then I wanted to build a company that could do, that could get venture funding, right? Better for worse. I mean, that's a longer story. We could talk a lot about that, but. And that's where Anaconda came to be. That's where Anaconda came to be. So let me ask you, it's a little bit for fun because you built this amazing thing. And so let's talk about like an old warrior looking over old battles. You've, there's a sad letter in 2012 that you wrote to the NumPy mailing list announcing that you're leaving NumPy. Yeah. And some of the things you've listed is some of the things you regret, or not regret necessarily, but some things to think about. If you could go back and you could fix stuff about NumPy or both sort of in a personal level, but also like looking forward, what kind of things would you like to see changed? Good question. So I think there's technical questions and social questions right there. First of all, you know, I wrote NumPy as a service and I spent a lot of time doing it. And then other people came help make it happen. NumPy succeeded because the work of a lot of people, right? So it's important to people understand that. I'm grateful for the option that the role I could play and grateful that things I did had an impact, but they only had the impact they had because the other people that came to the story. And so they were essential, but the way data types were handled, the way data types, we had array scalers, for example, that are really just a substitute for a type concept, right? So we had array scalers are actual Python objects so that there's for every, for a 32 bit float, or a 16 bit float, or a 16 bit integer. Python doesn't have a natural, it's just one integer, it's one float. Well, what about these lower precision types, these larger precision types? So we had them in NumPy so that you could have a collection of them, but then have an object in Python that was one of them. And there's questions about like in retrospect, I wouldn't have created those of an improved the type system. Like made the type system actually a Python type system as opposed to currently it's a Python one level type system. I don't know if you know the difference between Python one and Python two, it's kind of technical, kind of depth, but Python two, one of its big things that Guido did, it was really brilliant. It was actually Python one, all classes, new objects, were one, if you as a user wrote a class, it was an instance of a single Python type called the class type, right? In Python two, he used a meta typing hook to actually go, oh, we can extend this and have users write classes that are new types. So he was able to have your user classes be actual types and the Python type system got a lot more rich. I barely understood that at the time that NumPy was written. And so I essentially in Python NumPy created a type system that was Python one era. It was every D type is an instance of the same type as opposed to having new D types be really just Python types with additional metadata. What's the cost of that? Is it efficiency, is it usability? It's usability primarily. The cost isn't really efficiency. It's the fact that it's clumsy to create new types. It's hard. And then one of the challenges, you wanna create new types. You wanna quaternion type, or you wanna add a new, you know, posit type, or you wanna, so it's hard. Now, and now if we'd have done that well, when Numba came on the scene, where we could actually compile Python code, it would integrate with that type system much cleaner. And now all of a sudden you could do gradual typing more easily. You could actually have Python when you add Numba plus better typing. Could actually be a, you'd smooth out a lot of rough edges. But there's already, there's like, are you talking about from the perspective of developers within NumPy or users of NumPy? Developers of new, not really users of NumPy so much, it's the development of NumPy. You're thinking about like how to design NumPy so that it's contributors. Yeah, the contributors, it's easier. It's easier. It's less work to make it better and to keep it maintained. And where that's impacted things, for example, is the GPU. Like all of a sudden, GPUs start getting added and we don't have them in NumPy. Like NumPy should just work on GPUs. The fact that we have to, you'd have to download a whole other object called Kupy to have arrays on GPUs is just an artifact of history. Like there's no fundamental reason for it. Well, that's really interesting if we could sort of go on that tangent briefly is you have PyTorch and other library like TensorFlow that basically tried to mimic NumPy. Like you've created a sort of platonic form of one of multi-dimensional. Yeah, exactly. Well, and the problem was I didn't realize that. The platonic form has a lot of edges that are like, well, we should cut those out before we present it. So I wonder if you can comment, is there like a difference between their implementations? Do you wish that they were all using NumPy or like in this abstractional GPU? And sorry to interrupt it, there's GPUs, ASIC. There might be other neuromorphic computing. There might be other kind of, or the aliens will come with a new kind of computer. Like an abstraction that NumPy should just operate nicely over the things that are more and more and smarter and smarter with this multi-dimensional arrays. Yeah, yeah. I have several comments there. We are working on something now called data-apis.org. data-api.org, you can go there today. And it's our answer. It's my answer. It's not just me, it's me and Rolf and Athan and Aaron and a lot of companies are helping us at Quonsight Labs. It's not unifying all the arrays, it's creating an API that is unified. So we do care about this and trying to work through it. I actually had the chance to go and meet with the TensorFlow team and the PyTorch team and talk to them after exiting Anaconda, just talking about, because the first year after leaving Anaconda in 2018, I became deeply aware of this and realized that, oh, this split in the array community that exists today makes what I was concerned about in 2005 pretty parochial. It's a lot worse, right? Now there's a lot more people. So perhaps the industry can sustain more stacks, right? There's a lot of money, but it makes it a lot less efficient. I mean, this, but I've also learned to appreciate, it's okay to have some competition. It's okay to have different implementations, but it's better if you can at least refactor some parts. I mean, you're gonna have to be more efficient if you can refactor parts. It's nice to have competition over things over which it's nice to have competition. They're innovative. Yeah, innovative. And then maybe on the infrastructure, whatever, however you define infrastructure, that maybe it's nice to have come together. That's a collaboration, exactly. I agree. And I think, but it was interesting to hear the stories. I mean, TensorFlow came out of the C++ library, Jeff Dean wrote, I think. There was basically how they were doing inference, right? And then they realized, oh, we could do this TensorFlow thing. That C++ library, then what was interesting to me was the fact that both Google and Facebook did not, it's not like they supported Python or NumPy initially. They just realized they had to. They came to this world and then all these were like, hey, where's the NumPy interface? Oh, then they kind of came late to it. And then they had these bolt-ons. TensorFlow's bolt-on, I don't mean to offend, but it was so bad. Yeah, it was. It's the first time that I'm usually, I mean, one of the challenges I have is I don't criticize enough because in the sense that I don't give people input enough. You know, if- I think it's universally agreed upon that the bolt-ons on TensorFlow- Great. It was a talk given at Mallorca in Spain and a guy, great guy, came and gave a talk. I said, you should never show that API again at a PyData conference. Like that was, that's terrible. Like you're taking this beautiful system you've created and like you're corrupting all these poor Python people, forcing them to write code like that or thinking they should. Fortunately, you know, they adopted Keras as their, and that's, Keras is better. And so Keras TensorFlow is fine, is reasonable. But they bolted it on. Facebook did too, like Facebook had their own C++ library for doing inference. And they also had the same reaction, they had to do this. One big difference is Facebook, maybe because the way it's situated in part of FAIR, part of their research library, TensorFlow is definitely used and, you know, they have to make, they couldn't just open it up and let the community, you know, change what that is because I guess they were worried about disrupting their operations. Facebook's been much more open to having community input on the structure itself. Whereas Google and TensorFlow, they're really eager to have community users, people use it and build the infrastructure, but it's much more walled. Like it's harder to become a contributor to TensorFlow. And it's also, this is very difficult question to answer and don't mean to be throwing shade at anybody, but you have to wonder, it's the Microsoft question of when you have a tool like PyTorch or TensorFlow, how much are you tending to the hackers and how much are you tending to the big corporate clients? Correct. So like the ones that, do you tend to the millions of people that are giving you almost no money or do you tend to the few that are giving you a ton of money? I tend to stand with the people. Right. Because I feel like if you nurture the hackers, you will make the right decisions in the long term that will make the companies happy too. I lean that way too, I totally agree. But then you have to find the right data. But it's a balance. Because you can lean to the hackers and run out of money. Yeah, exactly. Which has been some of the challenge I've faced in the sense that, like I would look at some of the experiments like NumPy, the fact that we have the split is a factor of I wasn't able to collect more money towards NumPy development. Yeah. Right, I mean, I didn't succeed in the early days of getting enough financial contribution to NumPy so they didn't make me work on it. Right, I couldn't work on it full time. I had to just catch an hour here, an hour there. And I basically not like that. Like I've wanted to be able to do something about that for a long time and trying to figure out how, well, there's lots of ways. I mean, possibly one could say, we had an offer from Microsoft early days of Anaconda. 2014, they offered to come buy us, right? The problem was the right people at Microsoft didn't offer to buy us. And they were still, it was really a, we were like a second, they had really bought, they just bought R, the R company called, it was not RStudio, but it was another R company that was emergent. And it was kind of a, well, we should also get a Python play. But they were really double down on R, right? And so it was like, It was where you would go to die. So it's not, it wasn't, it was before Satya was there. Satya had just started. Just started. Right, and the offer was coming from someone two levels down from him. Gotcha. Right, and if it had come from Scott Guthrie, so I got a chance to meet Scott Guthrie, great guy, I like him. If it offered to come from him, probably would be at Microsoft right now. That'd be fascinating. That would be really nice actually, especially given what Microsoft has since done for the open source community and all of those. Yes, I think they're doing well. I really like some of the stuff they've been doing. They're still working, and they've hired Guido now, and they've hired a lot of Python developers. Wait, Guido's not Microsoft? I need to. Microsoft. Which he retired, then he came out of retirement and he's working out. So I was just talking to him and he didn't mention this part. Well. I should have, I should have, but I get this further. Well. Because I know he loved Dropbox, but I wasn't sure what he was doing, who he was up to. Well, he was kind of saying he would retire a bit. And it's literally been five years since I last sat down and really talked to Guido. Right? Guido's a technology expert, right? He's a, so I came, I was excited because I'd finally figured out the type system for NumPy. I wanted to kind of talk about that with him, and I kind of overwhelmed him. Could you stay in that just for a brief moment? Because you're a fascinating person in the history of programming. He is a fascinating person. What have you learned from Guido about programming, about life? Yeah, yeah, a lot actually. I've been a fan of Guido's, you know, we have a chance to talk. Some, I wouldn't say, you know, we talk all the time, not only at all, he may, but we talked enough to, I respect his, like when I first started NumPy, one of the first things I did was I had, I asked Guido for a meeting with him and Paul Dubois and San Mateo. And I went and met him for lunch. And basically to say, maybe we can actually, part of the strategy for NumPy was to get it into Python 3 and maybe be part of Python. And so we talked about that. That's a cool conversation. And about that approach, right? I would have loved to be a fan in the water. That was good. And over the years for Guido, I learned, so he was open, like he was willing to listen to people's ideas, right? And over the years, now generally, you know, I'm not saying universally that's been true, but generally that's been true. So he's willing to listen, he's willing to defer, like on the scientific side, he would just kind of defer. He didn't really always understand what we were doing. Yeah. And he'd defer. One place where he didn't enough was we missed a matrix multiply operator. Like that finally got added to Python, but about 10 years later, it should have. But the reason was because nobody, it takes a lot of effort. And I learned this while I was writing NumPy. I also wrote tools to, I think I'm gonna have a Python dev and I added some pieces of Python, like the memory view object. I wanted the structure of NumPy into Python. So we didn't get NumPy into Python, but we got the basic structure of it into Python, like so you could build on it. Nobody did for a while, but eventually he database author started to. And it's a lot better they did. And also Antoine Petro and Stefan Kraw actually fixed the memory view object because I wrote the underlying infrastructure in C, but the Python exposure was terrible until they came in and fixed it, partly because I was already NumPy and NumPy was the Python exposure. I didn't really care about if you didn't have NumPy installed. Anyway, Guido opened up ideas, technologically brilliant, like really, I really got a lot of respect for him when I saw what he did with this type class merger thing. It was actually tricky, right? And then willing to share, willing to share his ideas. So the other thing, early on in 1998, I said I wrote my first extension module. The reason I could is because he wrote in this blog post on how to do reference counting, right? And without it, I would have been lost, right? But he was willing to at least try to write this post. And so he's been motivated, he's been motivated early on with Python that there's a computer science for everybody. We kind of have this early on desire to, oh, maybe we should be pushing programming to more people. So he had this populist notion, I guess, or populist sense. So learn that there's a certain skill, and I've seen it in other people too, of engaging with contributors sufficiently to, because when somebody engaged with you and wants to contribute to you, if you ignore them, they go away. So building that early contributor base requires real engagement with other people. And he would do that. Can you also comment on this tragic stepping down from his position as the benevolent dictator for life over the wars, you know. The Walrus operator. The Walrus operator was the last battle. I don't know if that's the cause of it, but there's this for people who don't know, you can look up, there's the Walrus operator, which looks like a colon and equal sign. Yeah, colon, equal sign. And it actually does maybe the thing that an equal sign should be doing. Yeah, maybe, right, exactly. But it's just historically, an equal sign means something else, it just means assignment. So he stepped down over this. What do you think about the pressure of leadership? It's something that you mentioned the letter I wrote in Numpy at the time. That was a hard time, actually. I mean, you know, there's been really hard times. It was hard. You know, you get criticized, right? And you get pushed and you get, not everybody loves what you do. Like anytime you do anything that has impact at all, you're not universally loved, right? You get some real critics. And that's an important energy because it's impossible for you to do everything right. You need people to be pushing. But sometimes people can get mean, right? People can, I prefer to get people to benefit the doubt. I don't immediately assume they have bad intentions. And maybe for other, you know, maybe that doesn't happen for everybody, they, for whatever reason, their past or their experience of people, they sometimes have bad, they immediately attribute you bad intentions. They're like, where did this come from? I mean, I definitely open to criticism, but I think you're misinterpreting the whole point. Cause I would get that, you know, certainly when I started Anaconda, you know, I've been, sometimes I say to people, I know I'm, I care enough about entrepreneurship to make some open source people uncomfortable. And I care enough about open source to make investors uncomfortable. So I sort of, you know, create, you create kind of doubters on both sides. So when you have, and this is just a plea to the listener and the public. I've noticed this too, that there's a tendency and social media makes this worse. When you don't have perfect information about the situation, you tend to fill the gaps with the worst possible, or at least a bad story that fills those gaps. And I think it's good to live life, maybe not fully naively, but filling in the gaps with the good, with the best, with the positive, with the hopeful explanation of why you see this. So if you see somebody like you trying to make money on a book about numpy, there's a million stories around that that are positive. And those are good to think about, to project positive intent on other people. Because for many reasons, usually, because people are good and they do have good intent. And also when you project that positive intent, people step up to that too. Yes. So like it's, it has this- It's a great point. It has this kind of viral nature to it. And of course, with Twitter early on, figured out on Facebook is that they can make a lot of money and engagement from the negative. Yes. And so like there's this, we're fighting this mechanism. I agree. Which is challenging. It's like easier. It's just easier to be- To be negative. And then for some reason, something in our mind really enjoys sharing that and getting, getting all excited about the negativity. We do. Yeah. But- Some protective mechanism perhaps that we're, we're already, we're gonna eat and if we don't. Exactly. For us to be effective as a group of people in a software engineering project, you have to project positive intent, I think. I totally agree. Totally agree. And I think that's very, and so that happens in this space, but Python has done a reasonable job in the past, but here's a situation where I think it started to get this pressure where it didn't. I was, I really didn't, I didn't know enough about what happened. You know, talked to several people about it. And I know most of the steering committee members today, one person nominated me for that role, but it's the wrong role for me right now, right? I have a lot of respect for the Python developer space and the Python developers. I also understand the gap between computer science Python developers and array programming developers or science developers. And in fact, Python succeeds in the array space, the more it has people in that boundary. And there's often very few. Like I was playing a role in that boundary and working like everything to try to keep up with the, even what Gita was saying. Like I'm a C programmer, but not a computer scientist. Like I was a engineer and physicist and mathematician. And I didn't always understand what they were talking about and why they would have opinions the way they did. So you have to listen and try to understand. Then you also have to explain your point of view in a way they can understand. And that takes a lot of work. And that communication is always the challenge. And it's just what we're describing here about the negativity is just another form of that. Like how do we come together? And it does appear we're wired anyway to at least have a, there's a part of us that little enemy, friend enemy. And we see, yeah, it's like, why are we wiring on the enemy front? So why are we pushing that? Why are we promoting that so deeply? Assume friend until proven otherwise. Yes, yes. So cause you have such a fascinating mind and all this. Let me just ask you these questions. So one interesting side on the Python history is the move from Python two to Python three. You mentioned move from Python one to Python two, but the move from Python two to Python three is a little bit interesting because it took a very long time. It broke in quite a small way backward compatibility. But even that small way seemed to have been very painful for people. Is there lessons you draw? Oh man, tons of lessons. From how long it took and how painful it seemed to be. Yeah, tons of lessons. Well, I mentioned here earlier that NumPy was written in 2005. It was in 2005 that I actually went to Guido to talk about getting NumPy into Python three. Like my strategy was to, oh, we were moving to Python three, let's have that be. It seems funny in retrospect because like, wait, Python three, that was in 2020, right? Where we finally ended up support for Python two or at least 2017. The reason it took a long time, I think it was because, but one of the things is there wasn't much to like about Python three. 3.0, 3.1, it really wasn't until 3.3, like I consider Python 3.3 to be Python 3.0. But it wasn't until Python 3.3 that I felt there was enough stuff in it to make it worth anybody using it, right? And then 3.4 started to be, oh yeah, I want that. And then 3.5 as the matrix role play operator, and now it's like, okay, we gotta use that. Plus the libraries that started leveraging some of the features of Python three. Exactly. So it really, the challenge was, it was, but it also illustrated a truism that, you know, when you have inertia, when you have a group of people using something, it's really hard to move them away from it. You can't just change the world on them. And Python three, you know, it made some, I think it fixed some things Guido had always hated. I think he didn't like the fact that print was a statement. He wanted to make it a function. But in some sense, that's a bit of gratuitous change to the language and you could argue, and there's people have. But there was, one of the challenges was there wasn't enough features and too many just changes without features. And so the empathy for the end user as to why they would switch wasn't there. I think also it illustrated just the funding realities. Like Python wasn't funded. Like it was also a project with a bunch of volunteer labor. Right? It had more people, so more volunteer labor, but it was still, it was fun in the sense that at least Guido had a job. And I've learned some of the behind the scenes on that now since, since talking to people who lived through it and maybe not on air, we can talk about some of that. But it's interesting to see, but Guido had a job, but his full-time job wasn't just work on Python. Like he had other things to do. Just wild. It is wild, isn't it? As wild how few people are funded. Yes. And how much impact they have. Yes. Maybe that's a feature in our bug. I don't know. Maybe, yes, exactly. At least early on, like it's sort of, I know, yeah. It's like Olympic athletes are often severely underfunded, but maybe that's what brings out the greatness. Yes, correct. No, exactly. Maybe this is the essential part of it. Cause I do think about that in terms of, I currently have an incubator for open source startups. What I'm trying to do right now is create the environment. I wish it existed when I was leaving academia with NumPy and trying to figure out what to do. I'm trying to create those opportunities and environments. So, and that's what drives me still is how do I make the world easier for the open source entrepreneur? So let me stay. I mean, I could probably stand up for a long time, but this is fun question. So Andre Kapathy leads the Tesla autopilot team. And he's also one of the most like legit programmers. I know. It's like he builds stuff from scratch a lot. And that's how he builds intuition about how a problem works. He just build it from scratch and I always love that. And the primary language he uses is Python for the intuition building. But he posted something on Twitter saying that they got a significant improvement on some aspect of their like data loading, I think, by switching away from np.squareroot. So the NumPy is implementation of square root to math.squareroot. And then somebody else commented that you can get even a much greater improvement by using the vanilla Python square root, which is like. Power 0.5. Power 0.5. And it's fascinating to me. I just wanted to. So that was some shade throwing at some. No, no. But also just. We're talking about. It's a good way to ask the trade off between usability and efficiency broadly in NumPy, but also on these specific weird quirks of like a single function. So on that point, if you use a NumPy math function on a scalar, it's going to be slower than using a Python function on that scalar. But because the math object in NumPy is more complicated, because you can also call that math object on an array. And so effectively, it goes through a similar machine. There aren't enough of the what you would do and you could do, like checks and fast paths. So yeah, if you're basically doing a list, if you run over a list. In fact, for problems that are less than 1,000, even maybe 10,000, if you're going more than 10,000, that's where you definitely need to be using arrays. But if you're less than that, and for reading, if you're doing a reading process, and essentially it's not compute bound, it's IO bound. And so you're really taking lists of 1,000 at a time and doing work on it. Yeah, you could be faster just using Python. Straight up Python. See, but also, this is the society and job. There's the fundamental questions when you look at the long arc of history. It's very possible that np.square is much faster. It could be. So like in terms of like, don't worry about it. It's the evils of over optimization or whatever, all the different quotes around that is sometimes obsessing about this particular little quirk is not sufficient. For somebody like, if you're trying to optimize your path, I mean, I agree, premature optimization creates all kinds of challenges, right? Because now, but you may have to do it. I believe the quote is the root of all evil. The root of all evil, right. Let's get Donald Knuth I think, or we can find somebody else. Well, Doc Knuth is kind of like Mark Twain. He would just attribute stuff to him. And it's fine because he's brilliant. So, no, I was a LaTeX user myself. And so I have a lot of respect and he did more than that, of course, but yeah. Someone I really appreciate in the computer science space. Yeah, I don't, I think that's appropriate. There's a lot of little things like that where people actually, if you understood it, you go, yeah, of course that's the case. Like, and the other part, the other part I didn't mention, and Numba was a thing we wrote early on. And I was really excited by Numba because it's something we wanted. It was a compiler for Python syntax. And I wanted it from the beginning of writing NumPy because of this function question, like taking the power of arrays is really that you can write functions using all of it. It has implicit looping, right? So you don't worry about, I write this n-dimensional for loop with four loops, four, four statements. You just say, oh, big four dimensional array, I'm gonna do this operation, this plus, this minus, this reduction, and you get this, it's called vectorization in other areas, but you can basically think at a high level and get massive amounts of computation done with the added benefit of, oh, it can be paralyzed easily. It can be put in parallel. You don't have to think about that. In fact, it's worse to go decompose your, you write the for loops and then try to infer parallelism from for loops. It's actually a harder problem than to take the array problem and just automatically parallelize that problem. That's what, and so functions in NumPy are called universal functions, UFunks. So square root is an example of a UFunk. There are others, sine, cosine, add, subtract. In fact, one of those first libraries to SciPy was something called special where I added Bessel functions and all these special functions that come up in physics and I added them as UFunks so they could work on arrays. So I understood UFunks very, very well from day one inside of numeric. That was one of the things we tried to make better in NumPy was how did they work? Can they do broadcasting? What does broadcasting mean? But one of the problems is, okay, what do I do with a Python scalar? So what happens, the Python scalar gets broadcast to a zero dimensional array and then it goes through the whole same machinery as if it were a 10,000 dimensional array. And then it kind of unpacks the element and then does the addition. That's not to mention the function it calls in the case of square root is just the C lib square root. In some cases, like Python's power, there's some optimizations they're doing that can be faster than just calling the C lib square root. In the interpreter or in the- No, in the C code, in the Python runtime. In the Python, right? So they really optimize it and they have the freedom to do that because they don't have to worry about- It's just a scalar. It's just a scalar. They don't have to worry about the fact that, oh, this could be an object with many pieces. The UFunk machiner is also generic in the sense that typecasting and broadcasting. Broadcasting is the idea of I'm gonna go, I have a zero dimensional array, I have a scalar with a four dimensional array and I add them. Oh, I have to kind of coerce the shape of this guy to make it work against the whole four dimensional array. So it's the idea of I can do a one dimensional array against a two dimensional array and have it make sense. Well, that's what NumPy does is it challenges you to reformulate, rethink your problem as a multi-dimensional array problem versus like move away from scalars completely. Right, exactly. Yeah. Exactly. In fact, that's where some of the edge cases boundaries are is that, well, they still there and this is where array scalars are particular. So array scalars are particularly bad in the sense that they were written so that you could optimize the math on them, but that hasn't happened, right? And so their default is to coerce the array scalar to a zero dimensional array and then use the NumPy machinery. That's what, and you could specialize, but it doesn't happen all the time. So in fact, when we first wrote NumPy, we do comparisons and say, look, it's a thousand X speed up. We're lying a little bit in the sense that, well, first do the 40X slowdown of using array scalars inside of a loop. Because if you just use Python scalars, you'd already be 10 times faster. But then we would get a hundred times faster over that using just compilation. And what we do is compile the loop from out of the interpreter to machine code. And then that's always been the power of Python is this extensibility so that you can, could people say, oh, Python's so slow? Well, sure, if you do all your logic in the runtime of the Python interpreter, yeah. But the power is that you don't have to. You write all the logic, what you do in the high level is just high level logic. And the actual calls you're making could be on gigabyte arrays of data. And that's all done at compiled speeds. And the fact that integration is one can happen, but two is separable. That's one of the, the language like Julia says, we're going to be all in one. You can do all of it together. And then there's the juries out, is that possible? I tend to think that you're going to, there's separate concerns there. You want to pre-compile, but generally you will want to pre-compile your some of your loops. Like Sci-Fi is a compilation step to install Sci-Fi. It takes about two hours. If you have many machines, maybe you can get it down to one hour, but to compile those libraries takes about, takes a while. You don't want to do that at runtime. You don't want to do that all the time. You want to have this pre-compiled binary available that you're then just linking into. So there's real questions about the whole source code. Code is running binary code is more than source code. It's create object code. It's the linker, it's the loader. It's the, how does that interpret it inside of a virtual memory space? There's a lot of details there that actually I didn't understand for a long time until I, you know, read books on the topic and it led to, the more you know, the better off you are and you can do more details, but sometimes it helps with abstractions too. Well, the problem, as we mentioned earlier with abstractions is you kind of sometimes assume that whoever implemented this thing had your case in mind and found the optimal solution. Yes. Or like you assume certain things. I mean, there's a lot of, Correct. One of the really powerful things to me early on, I mean, it sounds silly to say, but with Python, probably one of the reasons I fell in love with it is dictionaries. Yes. So obviously probably most languages have some Mapping concept. Some mapping concept, but it felt like it was a first-class citizen and it was just my brain was able to think in dictionaries, but then there is the thing that I guess I still use to this day is ordered dictionaries because that seems like a more natural way to construct dictionaries. Yeah. And from a computer-sized perspective, the running time cost is not that significant, but there's a lot of things to understand about dictionaries that the abstraction kind of doesn't necessarily incentivize you to understand. Right. Do you really understand the notion of a hash map and how the dictionary is implemented? But you're right. Dictionaries are a good example of an abstraction that's powerful. And I agree with you. One of the, I agree. I love dictionaries too. It took me a while to understand that once you do, you realize, oh, they're everywhere. Yeah. And Python uses them everywhere too. Like it's actually constructed one of the foundational things as dictionaries and it does everything with dictionaries. Yeah. So it is, it's powerful. I think dictionaries came later, but it is very, very powerful. It took me a little while coming from just the array programming entirely to understand these other objects, like dictionaries and lists and tuples and binary trees. I guess that I wasn't a computer scientist, but I studied arrays first. And so I was very array-centric and you realize, oh, these others don't have purposes and value actually. I agree. There's a friendliness about, like one way to think about arrays is arrays are just like full of numbers, but to make them accessible to humans and make them less error prone to human users, sometimes you want to attach names, human interpretable names that are sticky to those arrays. So that's how you start to think about dictionaries is, Yeah, good point. you start to convert numbers into something that's human interpretable. And that's actually the tension I've had. Correct. With NumPy because. Correct. I've built so much tooling around human interpretability and also protecting me from a year later not making the mistakes by being, I wanted to force myself to use English versus numbers. Yes. So there's a project called label the arrays. Like very early it was recognized that, oh, we need, we were indexing NumPy with just numbers, all the columns and particularly the dimensions. I mean, if you have an image, you don't necessarily need to label each column a row, but if you have a lot of images or you have another dimension, you at least like to label the dimension as this is X, this is Y, this is Z, or this is give us some human meaning or some domain meaning. That was one of the impetus for pandas actually, was just, oh, we do need to label these things. And label array was an attempt to add that, like a lighter weight version of that. And there's been, like, that's an example of something I think NumPy could add, could be added in NumPy. But one of the challenges again, how do you fund this? Like I said, one of the tragedies I think is that, so I never had the chance to, I was never paid to work on NumPy, right? So I've always just done it in my spare time, always taken from one thing, taken from another thing to do it. And at the time, I mean, today, it would be the wrong time today, like paying me to work on NumPy now would not be a good use of effort. But we are finally at QuantSight Labs, I'm actually paying people to work on NumPy and SciPy, which is I'm thrilled with, I'm excited by, I've wanted to do that. That's why I wanted to do from day one, it just took me a while to figure out a mechanism to do that. Even like in the university setting, respecting that, like pushing students, young minds, young graduate students to contribute, and then figuring out financial mechanisms that enable them to contribute, and then sort of reward them for their innovative scientific journey, that would be nice. But then also just a better allocation of resources. Well, it's 20 year anniversary since 9-11, and I was just looking, we spent over $6 trillion in the Middle East after 9-11, in the various efforts there. And sort of to put politics and all that aside, it's just, you think about the education system, all the other ways we could have possibly allocated that money. To me, to take it back, the amount of impact you would have by allocating a little bit of money to the programmers, that build the tools that run the world is fascinating. I don't know, I think, again, there is some aspect to being broke as somewhat of a feature, not a bug, that you make sure that you're valued. But you've still managed that. Right, no, I know. But I don't think that's a big part. So it's like, I think you can have enough money and actually be wealthy while maintaining your values. Agreed, agreed. There's an old adage that nations that trade together don't go to war together. I've often thought about nations that code together. Yeah, code together. Because one of the things I love about open source is it's global, it's multinational. Like there aren't national boundaries. One of the challenges with business and open source is the fact that, well, business is national. Like businesses are entities that are recognized in legal jurisdictions, and have laws that are respected in those jurisdictions and hiring, and yet the open source ecosystem is not there. Like currently, one of the problems we're solving is hiring people all over the world. Right, because it's a global effort. And I've had the chance to work, and I've loved the chance. I've never been to like Iran, but I once had a conference where I was able to talk to people there. Right, and talk to folks in Pakistan. Never been there, but we had a call. And there were people there, like just scientists and normal people. And there's a certain amount of humanizing, right? That gets away from the, like we often get the memes of society that bubble up and then get her get discussed. But the memes are not even an accurate reflection of the reality of what people are. Well, if you look at the major power centers that are leading to something like cyber war in the next few decades, it's the United States, it's Russia and China. And those three countries in particular have incredible developers. So if they work together, I think that's one way, the politicians can do their stupid bickering, but like there's a layer of infrastructure, of humanity. If they collaborate together, that I think can prevent major military conflict, which would, I think most likely happen at the cyber level versus the actual hot war level. You're right. No, I think that's good prediction. Nations that code together and don't go to war together. Don't go to war together. That's a hope, right? That's one of the philosophical hopes, but yeah. So you mentioned the project of Numba, which is fascinating. So from the early days, there was kind of a pushback on Python that it's not fast. You know, you see C++, if you want to write something that's fast, you use C, C++. If you want to write something that's usable and friendly, but slow, you use Python. And so what is Numba? What is its goal? How does it work? Great. Yeah. Yes. That's what the argument and the reality was people would write high level coding and use compiled code, but there's still user story use cases where you want to write Python, but then have it still be fast. You still need to write a for loop. Like before Numba, it was always don't write a for loop. You know, write it in a vectorized way, you know, put it in an array. And often that can make a memory trade off. Like quite often you can do it, but then you make maybe use more memory because you have to build this array of data that you don't necessarily need all the time. So Numba was, it started from a desire to have kind of a vectorized that worked. A vectorized was a tool in NumPy. It was released, you give it a Python function and it gave you a universal function, a UFunk that would work on arrays. So you get the function that just worked on a scalar. Like you could make a, like the classic case was a simple function that an if then statement in it. So a Sine X over X function, sync function. If X equals zero, return one. Otherwise do Sine X over X. The challenge is you don't want that loop going into the Python. So you want a compiled version of that. But the vectorized in NumPy would just give you a Python function. So it would take the array of numbers and at every call do a loop back into Python. So it was very slow. It gave you the appearance of a UFunk, but it was very slow. So I always wanted a vectorized that would take that Python scalar function and produce a UFunk working on binary native code. So in fact, I had somebody work on that with PyPy and see if PyPy could be used to produce a UFunk like that early on in 2009 or something like that, 2010. They didn't work that well. It was kind of pretty bulky. But in 2012, Peter and I had just started Anaconda. We had, I had just, I had learned to raise money. That's a different topic, but I'd learned to raise money from friends, family and fools, as they say. And- That's a good line. Right. Oh, that's a good line. But so we were trying to do something. We were trying to change the world. Peter and I are super ambitious. We wanted to make array computing and we had ideas for really what's still, still the energy right now. How do you do at scale data science? And we had a bunch of ideas there, but one of them, I had just talked to people about LLVM and I was like, there's a way to do this. I just, I went, I heard about my friend Dave Beasley at a compiler course. So I was looking at compilers like, and I realized, oh, this is what you do. And so I wrote a version of Numba that just basically mapped Python byte code to LLVM. Nice. Right. So, and the first version is like, this works and it produces code that's fast. This is cool for, you know, obviously a reduced subset of Python. I didn't support all of the Python language. There had been efforts to speed up Python in the past, but those efforts were, I would say, not from the array computing perspective, not from the perspective of wanting to produce a vectorized improvement. They were from a perspective of speeding up the runtime of Python, which is fundamentally hard because Python allows for some constructs that aren't, you can't speed up, like it's this generic, you know, when it does this variable. So I from the start did not try to replicate Python's semantics entirely. I said, I'm going to take a subset of the Python syntax and let people write syntax in Python, but it's kind of a new language really. So it's almost like four loops, like focusing on four loops. So four loops, scalar arithmetic, you know, typed, you know, really typed language, a type subset. That was the key. So, but we wanted to add inference of types. So you didn't have to spell all the types out because when you call a function, so Python is typed, it's just dynamically typed. So you don't tell it what the types are, but when it runs, every time an object runs, there's a type for the variables, you know what it is. And so that was the design goals of Numba were to make it possible to write functions that could be compiled and have them use for NumPy arrays, like the need of support NumPy arrays. And so how does it work? Do you add a comment within Python that tells to do, like how do you help out the compiler? Yeah, so there isn't much actually, you don't. It's kind of magical in the sense that it just looks at the type of the objects and then does type inference to determine any other intermediate variables it needs. And then it was also because we had a use case that could work early, like one of the challenges of any kind of new development is if you have something that to make it work, it was gonna take you a long time, it's really hard to get out off the ground. If you have a project where there's some incremental story, it can start working today and solve a problem, then you can start getting it out there, getting feedback. Because Numba today, now Numba is nine years old today, the first two, three versions were not great, right? But they solved a problem and so people could try it and we could get some feedback on it. Not great and it was very focused. Very fragile, very subsubtited. The subset it would actually compile was small. And so if you wrote Python code and said, so the way it worked is you write a function and you say at JIT, use decorators. So decorators, just these little constructs let you decorate code with an app and then a name. The at JIT would take your Python function and actually just compile it and replace the Python function with another function that interacts with this compiled function. And it would just do that. And we went from Python byte code, we then went to AST. Writing compiler is actually, I learned a lot about why computer science is taught the way it is because compilers can be hard to write. They use tree structures, they use all the concepts of computer science that are needed. And it's actually hard to, it's easy to write a compiler and then have it be spaghetti code. Like the past has become challenging and we ended up with three versions of Numba, right? Numba got written three times. What programming language is Numba written in? Python. Wait, okay. Yeah, Python. So. Really? Yeah. That's fascinating. Yeah, so Python, but then the whole goal of Numba is to translate Python byte code to LLVM. And so LLVM actually does the code generation. In fact, a lot of times I'd say, yeah, it's super easy to write a compiler if you're not writing the parser nor the code generator, right? For people who don't know LLVM is a compiler itself. So you're compiled. Yeah, it's really badly named low-level virtual machine, which that part of it is not used. It's really low level. Chris, he doesn't mean that. Yeah, love Chris. But the name makes you imply that the virtual machine is what it's all about. It's actually the IR and the library, the code generation. That's the real beauty of it. The fact that, what I love about LLVM was the fact that it was a plateau you could collaborate on, right? Instead of the internals of GCC or the internals of the Intel compiler, like how do I extend that? And here's a place where you collaborate. And we were early, I mean, people had started before. It's a slow compiler. Like it's not a fast compiler. So for some kind of JITs, like JITs are common in language because one, every browser has a JavaScript JIT. It does real-time compilation of the JavaScript to machine code. For people who don't know JIT is just in time compilation. Thank you, yeah, just in time compilation. They're actually really sophisticated. In fact, I got jealous of how much effort was put into the JavaScript JITs. Yes, well, it's kind of incredible what they've done with JavaScript JITs. I completely agree, I'm very impressed. But Numba was an effort to make that happen with Python. And so we used some of the money raised from Anaconda to do it. And then we also applied for this DARPA grant and used some of that money to continue the development. And then we used proceeds from service projects we would do. We get consulting projects on, that we would then use some of the profits to invest in Numba. So we ended up with a team of two or three people working on Numba. It was a fits and starts, right? And ultimately the fact that we had a commercial version of it also we were writing. So part of the way I was trying to fund Numba is say, well, let's do the free Numba and then we'll have a commercial version of Numba called Numba Pro. And what Numba Pro did is it targeted GPUs. So we had the very first CUDA JIT and the very first App JIT compiler that in 2012 for 13, you could run not just a view funk on CPU, but a view funk on GPUs. And it was automatically paralyzed it and get 1000X speed on it. And that's an interesting funding mechanism because large companies or larger companies care about speed in just this way. So it's exactly a really good way. Yeah, there's been a couple of things you know people will pay for. One, they'll pay for really good user interfaces, right? And so I'm always looking for what are the things people will pay for that you can actually adapt to the open source infrastructure. One is definitely user interfaces. The second is speed, like a better runtime, faster runtime. And then when we say people, you mean like a small number of people pay a lot of money, but then there's also this other mechanism that a ton of people pay a little bit. First, I gotta, we mentioned Anaconda, we mentioned friends, family and fools. So Anaconda is yet another, so there's a company, but there's also a project that is exceptionally impactful in terms of for many reasons, but one of which is bringing a lot more people into the community of folks who use Python. So what is Anaconda? What is its goals? Maybe what is Conda versus Anaconda? Yeah, I'll tell you a little bit of the history of that. Because Anaconda, we wanted to do, we wanted to scale Python, because Peter and I had the goal of when we started Anaconda. We actually started as Continuum Analytics, was the name of the company that started. It got renamed Anaconda in 2015. But we said we want to scale analytics. NumPy's great, pandas is emerging, but these need to run at scale with lots of machines. The other thing we wanted to do was make user interfaces that were web. We wanted to make sure the web did not pass by the Python community, that we had a ways to translate your data science to the web. So those are the two kind of technical areas, we thought, oh, we'll build products in this space. And that was the idea. Very quickly in, but of course the thing I knew how to do was to do consulting to make money and to make sure my family and friends and the whole city invested didn't lose their money. So it's a little different than if you take money from a venture fund. If you take money from a venture fund, the venture fund, they want you to go big or go home. And they're kind of like expecting nine out of 10 to fail or 99 out of 100 to fail. It's different, I was out of the barbell strategy. I was like, I can't fail. I mean, I may not do super well, but I cannot lose their money. So I'm gonna do something I know can return a profit, but I wanna have exposure to an upside. So that's what happened in a continent. There was lots of things we did not well in terms of that structure and I've learned from since and have it better, but we did a really good job of kind of attracting the interest around the area to get good people working and then give funnel some money on some interesting projects. Super excited about what came out of our energy there, like a lot did. So what are some of the interesting projects? So Dask, Numba, Bokeh, Conda, there was a Data Shader, Panel, Halleviz. These are all tools that are extremely relevant in terms of helping you build applications, build tools, build faster code. There's a couple of them beginning. So Bokeh is a plotting. Oh, Jupiter Lab, Jupiter Lab came out of this too. That's fascinating. Okay, so Bokeh does plotting, is that? Bokeh does plotting. So Bokeh was one of the foundational things to say, I wanna do plot in Python, but have the things show up in a web. Right, that's right, that's right, that's right. And plotting to me still, with all due respect to Matplotlib and Bokeh, feels like still an unsolved problem. Not a solved problem. It is, it's a big problem. Right, because you're, I mean, I don't know, it's visualization broadly. Yes, I think we've got a pretty good API story around certain use cases of plotting, but there's a difference between static plots versus interactive plots, versus, end user, I just wanna write a simple, Panda started the idea of here's a data frame, I'm gonna dot plot. I'm just gonna attach plot as a method to my object, which was a little bit controversial, right? But works pretty well actually, because there's a lot less you have to pass in, right? You could just say, here's my object, you know what you are. You tell the visualization what to do. So that, and there's things like that that have not been super well developed entirely, but Bokeh was focused on interactive plotting. So you could, it's a short path between interactive plotting and application, dashboard application. And there's some incredible work that got done there, right? And it was a hard project because then you're basically doing JavaScript and Python. So we wanted to tackle some of these hard problems and try to just go after them. We got some DARPA funding to help, and it was super helpful. Funny story there, we actually did two DARPA proposals, but one we were five minutes late for. And DARPA has a very strict cutoff window. And so we had two proposals, one for the Bokeh and one for actually Numba and the other work. Which one were you late for? The Foundation on the America work. So Bokeh got funded. Oh no. Fortunately, Chris let us use some of the money to fund still some of the other foundational work, but it wasn't his, yeah, his hands were tied. He couldn't do anything about it. That was a whole interesting story. So one of the incredible projects that you worked on is Conda. Yes. So what is Conda? How was that came about? Yeah, Conda, it was early on, like I said, with SciPy. SciPy was a distribution, masquerading as a library. And he said, we heard me talking about compiler issues and trying to get the stuff shipped and the fact that people can use your libraries if they have it. So for a long time, we'd understood the packaging problem in Python. And one of the first things we did at Cuntunum Analytics became Anaconda was organize the PyData ecosystem in conjunction with Numbfocus. We actually started Numbfocus with some other folks in the community the same year we started Anaconda. I said, we're gonna build a corporation, but we're also gonna reify the community aspect and build a nonprofit. So we did both of those. Can we pause real quick and can you say what is PyPy, the Python package index, like this whole story of packaging in Python? Yeah, that's what I'm gonna get to actually. This is exactly the journey I'm on. It's to sort of explain packaging in Python. I think it's best expressed to the conversation I had with Guido at a conference where I said, so, you know, packaging is kind of a problem and Guido said, I don't ever care about packaging. Don't use it. I don't install new libraries. I'm like, I guess if you're the language creator and if you need something, you just put it in the distribution. Maybe you don't worry about packaging. But Guido has never really cared about packaging, right? And never really cared about the problem of distribution. It's somebody else's problem. And that's a fair position to take, I think, as a language creator. In fact, there's a philosophical question about should you have different development packaging managers? Should you have a package manager per language? Is that really the right approach? I think there are some answers of, it is appropriate to have development tools. And there's an aspect of a development tool that is related to packaging. And every language should have some story there to help their developers create. So it should have language specific development tools. Development tools that relate to package managers. But then there's a very specific user story around package management that those language specific package managers have to interact with and currently aren't doing a good job of that. That was one of the challenges of not seeing that difference. And it still exists in the difference today. Conda always was a user, I'm gonna use Python to do data science. I'm gonna use Python to do something. How do I get this installed? It was always focused on that. So it didn't have a develop. Classic example is Pip has a Pip develop. It's like, I wanna install this into my current development environment today. Conda doesn't have that concept because it's not part of the story. For people who don't know, Pip is a Python specific packaging manager. That's exceptionally popular. That's probably like the default thing you've learned. It's the default user. Yeah, and so the story there emerged because what happened is in 2012, we had this meeting at the Googleplex and Guido was there to come talk about what we're gonna do. How we're gonna make things work better. And Wes McKinney, me, Peter, Peter has a great photo of me talking to Guido and he pretends we're talking about this story. Maybe we were, maybe we weren't. But we did at that meeting talk about it and asked Guido, Guido, we need to fix packaging in Python. People can't get the stuff. And he said, go fix yourself. I don't think we're gonna do it. All right. It's the origin story right there. All right, you said, okay, you said to do this ourselves. So at the same time, people did start to work on the packaging story in Python. It just took a little longer. So in 2012, kind of motivated by our training courses we were teaching, like very similar to what you just mentioned about your mother. Like it was motivated by the same purpose. Like, how do we get this into people's hands? And it's this big long process it takes to expensive. It was actually hurting NumPy development because I would hear people were saying, don't make that change to NumPy because I just spent a week getting my Python environment. And if you change NumPy, I have to reinstall everything. And reinstalling such a pain, don't do it. I'm like, wait, okay, so now we're not making changes to a library because of the installation problem that will cause for end users. Okay, there's a problem with pack, there's a problem with installation. We gotta fix this. So we said, we're gonna make a distribution of Python. And we'd previously done that at mthought. I wanted to make one that would give away for free. Everyone could just get, like that was critical that we just get it, you know, it wasn't tied to a product. It was just, you could get it. And then we had constantly thought about, well, do we just leverage RPM? But the challenge had always been, we want a package manager that works on Windows, Mac OS X and Linux the same, right? And it wasn't there. Like you don't have anything like that. And for people who don't know, RPM is Red Hat's package manager. Operating system specific package manager. Correct, it's an operating specific, yes. So do you create the design question is, do you create an umbrella package manager that works across operating systems? Yes, that was the decision. And a neighboring design question is, do you also create a package manager that spans multiple programming language? Correct, exactly. That was the world we faced. And we decided to go multiple operating systems, multiple and programming language independent. Because even Python, in particular what was important was, SciPy has a bunch of 4chan in it, right? And scikit-learn has links to a bunch of C++. There's a lot of compiled code. And the Python package managers, especially early on, didn't even support that. So in 2000, so we released Anaconda, which was just a distribution of libraries, but we started to work on Conda in 2012. First version of Conda came out in early 2013, some of it was 2013, and it was a package manager. So you could say Conda install scikit-learn. In fact, that was the, scikit-learn was a fantastic project that emerged. Kind of, it was the classic example of the scikits. I talked to you earlier about scipy being too big to be a single library. Well, what the community had done is said, let's make scikits. And there's scikit-image, there's scikit-learn, there's a lot of scikits. And it was a fantastic move, you know, that the community did, I didn't do it. I was like, okay, that's good idea. I didn't like the name. I didn't like the fact you typed scikit-image. I was like, that's gonna be simpler. SK-learn, we gotta make that smaller. I like typing all this stuff from imports. So I was kind of a pressure that way, but I love the energy and love the fact that they went out and they did it and also people, Jared Millman, and then of course, Guy L, and there's people I'm not even naming, that scikit-learn really emerged as fantastic project. And the documentation around that is also incredible. And the documentation was incredible, exactly. I don't know who did that, but they did a great job. A lot of people in NREA, a lot of people, like a lot of European contributors. Andreas, there's some Andreas in the US. There's a lot of just people I just adore. I think are amazing people. Awesome use of Sci-Fi, right? I love the fact that they were using Sci-Fi. Factually, I do something I love, which is machine learning, but couldn't install it. Cause there's so many pieces involved. So many dependencies, right? So our use case of Conda was Conda install scikit-learn, right? And it was the best way to install scikit-learn in 2013 to really 2018, 17, 18. Pip finally caught up. I still think it's you should conda install scikit-learn for the pip install scikit-learn, but you can pip install scikit-learn. The issue is the package they created was wheels and pip does not handle the multi-vendor approach. They don't handle the fact that you have C++ libraries you're depending on. They just stop at the Python boundary. And so what you have to do in the wheel world is you have to vendor. You have to take all of the binary and vendor it. Now, if your change happens on an early dependency, you have to redo the whole wheel. So TensorFlow is a good example of a, you should not pip install TensorFlow. It's a terrible idea. People do it because the popularity of pip, many people think, oh, of course, that's how I install everything in Python. Yeah, this is one of the big challenges. You take a GitHub repository or just a basic blog post. The number of time pip is mentioned over Conda is like a hundred X to one. Correct, correct. So they just have to do with the whole- And that was increasing. It wasn't true early because pip didn't exist. Like Conda came first. So, but that's like the long tail of the internet documentation user generated. So that like you think, how do I install, you Google, how do I install TensorFlow? You're just not gonna see Conda in that first page. Correct, exactly. And that- Not today. You would have in 2016, 2017. And it's sad because Conda solves a lot of usability issues. Correct. Like for especially super challenging thing, I don't know, one of the big pain points for me was just on the computer vision side, OpenCV. Yes, perfect example. I think Conda, I don't know if Conda solved that one. Conda has an OpenCV package. I don't know. I certainly know pip has not solved. I mean, there's complexities there because- Right. I actually don't know. I should probably know a good answer for this, but if you compile OpenCV with certain dependencies, you'll be able to do certain things. So there's this kind of flexibility of what you, like what options you compile with. Yes. And I don't think it's trivial to do that with Conda or with- So Conda has a notion of variants of a package. You can actually have different compilation versions of a package. So not just the versions different, but oh, this is compiled with these optimizations on. So Conda does have an answer. As of flavors, yeah. As of flavors, basically. Well, pip, as far as I know, does not have flavors. No, pip generally hasn't thought deeply about the binary dependency problem, right? And that's why fundamentally it doesn't work for the SciPy ecosystem. It barely, you can sort of paper over it and duct tape and it kind of works. Until it doesn't, it falls apart entirely. So it's been a mixed bag. And I've been having lots of conversations with people over the years because again, it's an area where if you understand some things, but not all the things, but they've done a great job of community appeal. This is an area where I think Anaconda as a company needed to do some things in order to make Conda more community-centric, right? And this is something, I talk about this all the time. There's a balance between, you have, every project starts with what I call company backed open source. Even if the company is yourself, it's just one person. Just doing business ads. But ultimately for products to succeed virally and become massive influencers, they have to create, they have to get community people on board, they have to get other people on board. So it has to become community driven. And a big part of that is engagement with those people, empowering people, governance around it. And there was, and what happened with Conda in the early days, PIP emerged, and we did do some good things. Conda Forge, Conda Forge community is sort of the community recipe creation community. But Conda itself, I still believe, and Peter is CEO of Anaconda, he's my co-founder. I ran Anaconda until 2017, 2018. It's Peter Stilin and- Peter Stilin and Conda, right? And we're still great friends. We talk all the time. I love him to death. There's a long story there about like why and how, and we can cover in some other podcasts perhaps. Yeah. It's sort of a more, maybe a more business focused one. But there's one area where I think Conda should be more community driven. Like he should be pushing more to get more community contributors to Conda and let the, like Anaconda shouldn't be fighting this battle. Yeah. Right? It's actually, it's really a developer's. Like you said, like help the developers. Yeah. And then they'll actually move us the right direction. Well, that was the problem I have is many of the cool kids I know don't use Conda. And that to me is confusing. It is confusing. And it's really a matter of, Conda has some challenges. First of all, Conda still needs to be improved. There's lots of improvements to be made. And it's that aspect of wait, who's doing this? And the fact that then the Pi PA really stepped up. Like they were not solving the problem at all. And now they kind of got to where they're solving it for the most part. And then effectively you could get, like Conda solved a problem that was there and it still does. And it's still, you know, there's still great things it can do, but, and we still use it all the time at Quonsight and with other clients, but with, but you can kind of do similar things with Pippin Docker. Right? So especially with the web development community, that part of it again is this is the, there's a lot of different kinds of developers in the Python ecosystem. And there's still a lack of some clear understanding. I go to the Python conference all the time and there's only a few people in the Pi PA who get it. And then others who are just massively trumpeting the power of Pipp, but just do not understand the problem. Yeah. So one of the obvious things to me from a mom, from a non-programmer perspective is the across operating system usability that's much more natural. So this really use windows and just, it seems much easier to recommend Conda there, but then you should also recommend it across the board. So I'll definitely sort of- What I recommend now as a hybrid, I do. I mean, I have no problem with Pipp. Is it possible to use? Oh, it is. It is what I, like build the environment with Pipp, with Conda, build an environment with Conda, and then Pipp install on top of that. That's fine. Be careful about Pipp installing OpenCV or TensorFlow or because if somebody's allowed that, it's going to be most surely done in a way that can't be updated that easily. So install like the big packages, the infrastructure, with Conda and then the weirdos that like the weird like implementation for some. I had, there's a cool library I used that based on your location and time of day and date, tells you the exact position of the sun relative to the earth. Oh, very cool. And it's just like a simple library, but it's very precise. And I was like, all right, but that was, that was in this Pipp. Well, the thing they did really well is Python developers who want to get their stuff published, they, you have to have a Pipp recipe, right? I mean, even if it's, you know, the challenge is, and there's a key thing that needs to be added to Pipp, just simply add to Pipp the ability to defer to a system package manager. Like, because it's, you know, recognize you're not going to solve all the dependency problem. So let like give up and allow the, allow a system packager to work. That way, Anaconda is installed and it has Pipp, it would default to Conda to install its stuff, but Red Hat RPM would default to RPM to install, it's all more things. Like that's the, that's a key, not difficult, but somewhat work, some work feature needs to be added. That's an example of something like, I've known we need to root and do it. I mean, it's where I wish I had more money. I wish I was more successful in the business side, trying to get there, but I wish my, you know, my family, friends and full community that I know. Was larger. Was larger and had more money. Because I know tons of things to do effectively with more resources, but you know, I have not yet been successful at channel, tons of it. You know, some, you know, I'm happy with what we've done. We've created again at Quonsight, what we created to get Anaconda started. We created Community Analytics to get Anaconda started. Done it again with Quonsight, super excited by that. By the way. It took three years to do it. What is Quonsight? What is its mission? We've talked a few times about different, fascinating aspects of it, but it's like big picture. What is Quonsight? Big picture Quonsight. Quonsight is, it's mission is to connect data to an open economy. So it's basically consulting the Pi data ecosystem, right? It's a consulting company. And what I've said when I started it was we're trying to create products, people and technology. So it's divided into two groups and a third one as well. The two groups are a consulting services company that just helps people do data science and data engineering and data management better and more efficient. Like full stack, full stack. Full stack, data science, full thing. What will help you build a infrastructure if you're using Jupyter, we need, we do staff orientation, need more programmers, help you use Dask more effectively, help you use GPUs more effectively. Just basically a lot of people need help. So we do training as well to help people, both immediate help and then get learn from somebody. We've added a bunch of stuff too. We've kind of separated some of these other things in another company called Open Teams that we currently started. One of the things I loved, but we did at Anaconda was creating a community innovation team. And so I wanted to replicate that. This time we did a lot of innovation at Anaconda. I wanted to do innovation, but also contribute to the projects that existed. Like create a place where maintainers, so that SciPy and NumPy and NumPy and all these projects we already started can pay people to work on them and keep them going. So that's Labs. QuantSight Labs is a separate organization. It's a nonprofit mission. The profits of QuantSight help fund it. And in fact, every project that we have at QuantSight, a portion of the money goes directly to QuantSight Labs to help keep it funded. So we've gotten several mechanisms we keep QuantSight Labs funded. And currently, so I'm really excited about Labs because it's been a mission for a long time. What kind of projects are within Labs? So Labs is working to make the software better, like make NumPy better, make SciPy better. It only works on open source. So if somebody wants to, so companies do, we have a thing called the community work order, we call it. If a company says, I wanna make Spider better. Okay, cool. You can pay for a month of a developer of Spider or a developer of NumPy or developer of SciPy. You can't tell them what you want them to do. You can give them your priorities and things you wish existed. And they'll work on those priorities with the community to get what the community wants and what emerges with the community wants. Is there some aspect on the consulting side that is helping as we were talking about morphology and so on, is there specific application that are particularly like driving, sort of inspiring the need for updates to SciPy and not find all of those things? Correct, absolutely, absolutely. GPUs are absolutely one of them. GPUs. And new hardware beyond GPUs. I mean, Tesla's dojo chip, I'm hoping we'll have a chance to work on that perhaps. Things like that are definitely driving it. The other thing is driving is scalable, like speed and scale. How do I write NumPy code or NumPy lite code if I wanted to run across a cluster? You know, that's Dask or maybe it's Ray. I mean, there's sort of ways to do that now or there's Moden and there's, so pandas code, NumPy code, SciPy code, second learn code, then I want to scale. So that's one big area. Have you gotten a chance to chat with Andre and Elon about because like- No, I would love to by the way. I have not, but I'd love to. I just saw their Tesla AI days video. Super excited. So this one of the, you know, I love great engineering, software engineering teams and engineering teams in general, and they're doing a lot of incredible stuff with Python. They're like- They are. Revolutionaries, so many aspects of the machine learning pipeline- I agree. That's operating in the real world. And so much of that is Python. Like you said, the guy running, you know, Andre Kupathy running autopilot is tweeting about optimization of NumPy versus- I would love to talk to him. That's a square root. In fact, we have at Quansight, we've been fortunate enough to work with Facebook on PyTorch directly. So we have about 13 developers at Quansight. Some of them are in labs working directly on PyTorch. On PyTorch. On PyTorch, right. So I basically, when we started Quansight, I went to both TensorFlow and PyTorch and said, hey, I want to help connect what you're doing to the broader SciPy ecosystem because I see what you're doing, but we have this bigger mission and we want to make sure we don't lose energy here. So, and Facebook responded really positively and I didn't get the same reaction. Not yet. Not yet. I love the folks at TensorFlow. I really love the folks at TensorFlow too. They're fantastic. I think it's the, just how it integrates with their business. I mean, like I said, there's a lot of reasons, just the timing, the integration with their business, what they're looking for. They're probably looking for more users. And I was looking to kind of cut some development effort and they couldn't receive that as easily, I think. So I'm hoping, I'm really hopeful and love the people there. What's the idea behind open teams? So open teams, I'm super excited about open teams because it's one of the, I mentioned my idea for investing directly in open source. So that's a concept called FeroSS. But one of the things we, when we started Quonsight, we knew we would do is we develop products and ideas and new companies might come out. And Anaconda, this was clear, right? Anaconda, we did so much innovation that like five or six companies could have come out of that. And we just didn't structure it so they could. But in fact, they have. You look at Basque, there's two companies coming out of Basque. You know, Bokeh could be a company. There's like lots of companies that could exist off the work we did there. And so I thought, oh, here's a recipe for an incubation, a concept that we could actually spawn new companies and new innovations. And then the idea has always been, well, money they earn should come back to fund the open source project. So labs is, I think there should be a lot of things like Quonsight Labs. I think this concept is one that scales. You could have a lot of open source research labs. Along the way, so in 2018, when the bigger idea came, how to make open source investor, I said, oh, I need to write it. I need to create a venture fund. So we created a venture fund called Quonsight Initiate at the same time. It's an angel fund, really. We started to learn that process. How do we actually do this? How do we get LPs? How do we actually go in this direction and build a fund? And I'm like, every venture fund should have an associated open source research lab, which is no reason. Like our venture fund, the carried interest, a portion of it goes to the lab. It directly will fund the lab. That's fascinating, brother. So you use the power of the organic formation of teams in the open source community and then naturally that leads to a business that can make up the money. There are some, yeah, correct. And then it always maintains and loops back to the open source. Loops back to open source, exactly. And between it's a natural fit. There's something, there's absolutely a repeatable pattern there. And it's also beneficial because, oh, I have natural connections to the open source if I have an open source research lab. Like they'll all be out there talking to people. And so we've had a chance to talk to a lot of early stage companies. And our fund folks on the early stage. So Quonsight has the services, the lab, the fund. In that process, a lot of stuff started to happen. And they were like, oh, we started to do recruiting and support and training. Then I was starting to build a bigger sales team and marketing team and people besides just developers. And one of the challenges with that is you end up with different cultural aspects. Developers, in any company you go to, you kind of go, look, is this a business led company, a developer led company? Do they kind of coexist? What's the interface between them? There's always a bit of a tension there. Like we were talking about before. What is the tension there? With open teams, I thought, wait a minute, we can actually just create this concept of Quonsight plus labs. While it's specific to the PyData ecosystem, the concept is general for all open source. So open teams emerged as, oh, we can create a business development company for many, many Quonsights, like thousands of Quonsights. And it can be a marketplace to connect, essentially be the enterprise software company of the future. If you look at what enterprise software wants from the customer side, and during this journey I've had the chance to work and sell to lots of companies, Exxon and Shell and JP Morgan, Bank of America, like the Fortune 100, and talk to a lot of people in procurement and see what are they buying and why are they buying. So I don't know everything, but I've learned a lot about, oh, what are they really looking for? And they're looking for solutions. They're constantly given products from enterprise software. Here's open source. Lead enterprise software. Now I buy it. And then they have to stitch it together into a solution. Open source is fantastic for gluing those solutions together. So whereas they keep getting new platforms they're trying to buy, what most enterprises want is tools that they can customize that are as inexpensive as they can. Yeah, and so you always want to maintain the connection to the open source because that's going to be the tools. Yes, so open teams is about solving enterprise software problems. Brilliant idea, by the way. But we do it honoring the topology. We don't hire all the people. We are a network connecting the sales energy and the procurement energy. And we were on the business side, get the deals closed, and then have a network of partners like Quonsight and others who we hand the deals to to actually do the work. And then we have to maintain. I feel like we have to maintain some level of quality control so that the client can rely on open teams to ensure their delivery. It's not just, here's a lead, go figure that out. But no, we're going to make sure you get what you need. By the way, it's such a skill. And I don't know if I have the patience or if I will have the patience to talk to the business people or more specific. I mean, there's all kinds of flavors of business people or like marketing people. There's a challenge. I hear what you're saying because I've had the same challenge. And it's true. There's sometimes you think, okay, this is way over rot. Yeah, but you have to become an adult. You have to, because the companies have needs. They have ways to make money. And they also want to learn and grow. And it's your job to kind of educate them in the best way, like the value of open source, for example. Right. And I'm really grateful for all my experiences over the past 14 years, understanding that side of it and still learning for sure. But not just understanding from companies, but also dealing with marketing professionals and sales professionals and people that make a career out of that understanding what they're thinking about and also understanding, well, let's make this better. We can really make a place. Open teams I see as the transmission layer between companies and open source communities, producing enterprise software solutions. Today we're taking on SaaS and Matlab and tools that we know we can replace for folks. Really, anytime you have a software tool at an organization where you have to do a lot of customization or make it work for you. It's not you're just buying this thing off the shelf and it works. It's like, okay, you buy this system and you customize it a lot, usually with expensive consultants to actually make it work for you. All of those should be replaced by open source foundations with the same customization. You're doing such important work, such important work in these giant organizations that are doing exactly that, taking some proprietary software and hiring a huge team of consultants that customize it and then that whole thing gets outdated quick. Correct. And so, I mean, that's brilliant. The one solution to that is high, kind of what Tesla is doing a little bit of, which is basically build up a software engineering team. Like build a team from scratch. Build a team from scratch and companies are doing it well, that's what they're doing right now. Yeah, exactly. That's okay. And you're creating a topology for some of that. You just don't have to do it. That's not the only answer. And so other companies can access this, it's being more accessible. That's really what they say, open teams is the future of enterprise software. We're still early. Like this idea just percolated over the past year as we've kind of grown Quonsite and realized the extensibility of it. We just finished in our seed round to help get more salespeople and then push the messaging correctly. And there's lots of tools we're building to make this easier. We wanna automate the processes. We feel like a lot of the power is the efficiency of the sales process. There's a lot of wasted energy in small teams and the sales energy to get into large companies and make a deal. There's a lot of money spent on that process. They're creating the tools and processes for themselves. So make that super seamless. So a single company can go, oh, I've got my contract with open teams, we've got a subscription they can get. They can make that procurement seamless. And then the fact they have access to the entire open source ecosystem. And we have a part of our work that's embracing open source ecosystems and making sure we're doing things useful for them. We're serving them. And then companies making sure they're getting solutions they care about. And then figuring out which targets we have. We're not taking on all of open source, all of enterprise software yet. But we're- Well, this feels like the future. The idea and the vision is brilliant. Can I ask you, why do you think Microsoft bought GitHub and what do you think is the future of GitHub? Great point. I thought it was a brilliant move. I think they did because Microsoft has always had a developer-centric culture. Like they always have. Like one of the things Microsoft's always done well is understand their power as developers, right? It's been, you know, Baltimore didn't necessarily make a good meme about how he approached that. But names are broadening that. I think that's why. Because they recognize GitHub is where developers are at. Right? And so- But do they have a vision like open teams type of situation, right? I don't think so yet. I mean, I don't think so. Are they just basically throwing money at developers to show their support? I think so. Without a topology, like you put it, like a way to leverage that. Like to give developers actual money. Right. I don't think so. I think they're still, it's an enterprise software company and they make a bunch of money. They make a bunch of games. They have a big company and they sell products. I think part of it is they know there's opportunity to make money from GitHub. Right? There's definitely a business there, you know, to sell to developers or to sell to people using development. I think there's part of that. I think part of it is also there's, they had definitely wanted to recognize that you need a value open source to get great developers, which is an important concept that was emerging over the past 10 years that, you know, PyData, we were able to convince J.P. Morgan to support PyData because of that fact, right? That was where the money for them putting a couple hundred thousand into supporting PyData for several conferences was they want developers. And they realized that developers want to participate in open source. So enterprise software folks don't always understand how their software gets used. Having spent a lot of time on the floors at J.P. Morgan, at In-shell, at ExxonMobil, you see, oh, these companies have large development teams. And then they're kind of dealing with the, what's being delivered to them. So I really feel kind of a privilege that I had a chance to learn some of these people and see what they're doing and even work alongside them, you know, as a consultant, using open source and trying to figure out how do we make this work inside of our large organization? Some of it is actually for a large organization, some of it is messaging to the world that you care about developers and you're the cool, you care. Like for example, like at Ford, because I talked to them, the car companies, right? They want to attract, you know, you want to take on Tesla and autopilot, you want to take that, right? And so what do you do there? You show that you're cool, like you try to show off that you care about developers and they have a lot of trouble doing that. And like one way, I think like Ford should have bought GitHub. They just show off. Yeah, that's a better idea, yeah. Like these old school companies, and it's in a lot of. It's a good point. It's a lot of different industries. There's probably different ways. It's probably an art. Oh, I, yeah. They show that you care to developers. And the developers, it's exactly what you say. Like for example, just spitballing here, but like Ford or somebody like that could give a hundred million dollars to the development of NumPy. And like literally, look at like the top most popular projects in Python and just say, we're just going to give money. Right. Like that's going to immediately make you cool. They could actually. Yeah. And in fact, they set up NumFocus to make it easy. But the challenge was is also you have to have some business development. Like it's a bit of a, it's a bit of a seeding problem, right? And you look at how, I've talked to the folks at Linux Foundation, know how they're doing it. I know how, and starting NumFocus, because we had two babies in 2012. One was Anaconda, one was NumFocus, right? And they were both important efforts. They had distinct journeys and super grateful that both existed and still grateful both exist. But there's different energies in getting donations as there is getting, this is important to my business. Like I'm selling something that, this is, I'm going to make money this way. Like you can tie it, if you can tie the message to an ROI for the company, it becomes a ringer. It's much more effective, right? So, and there are rational arguments to make. I've tried to have conversations with marketing, especially marketing departments. Like very early on, it was clear to me that, oh, you could just take a fraction of your marketing budget and just spend it on open source development and you get better results from your marketing. Like because- How do those, can I, sorry, I'm gonna try not to go on the rest here. What have you learned from the interaction with the marketing folks on that kind of, because you gave a great example of something that will obviously be much better investment in terms of marketing, is supporting open source projects. The challenge is not dissimilar from the challenge you have in academia, the different colleges, right? Knowledge gets very specific and very channeled, right? And so people get, they get a lot of learning in the thing they know about. And it's hard then to bridge that and to get them to think differently enough to have a sense that you might have something to offer. Cause it's different. It's like, well, how do I implement that? How do I, what do I do with that? Do I, which budget do I take from? Do I slow down my spend on Google ads or my spend on Facebook ads or do I not hire a content creator instead? Like there's an operational aspect to that, that you have to be the CMO, right? Or the CEO, you have to get the right level. So you have to hire at a high position level where they care about this and they slow down. Or they won't know how, right? And because you can also do it very clumsily, right? And I've seen, cause you can, you absolutely have to honor and recognize the people you're going to and the fact that if you just throw money at them, it could actually create more problems. Can I just say, this is not you saying, can I just, cause I just need, I need to say this. I've been very surprised how often marketing people are terrible at marketing. I feel like the best marketing is doing something novel and unique that anticipates the future. It feels like so much of the marketing practice is like what they took in school or maybe they're studying for what was the best thing that was done in the past decade. And they're just repeating that over and over as opposed to innovating. Like taking the risk, to me marketing is taking the big risk and being the first one to risk. Yeah, there's an aspect of data observation from that risk, right? That's, I think cause shared what they're doing already. But it absolutely, it's about, I think it's content. Like there's this whole world on content marketing that you could almost say, well, yeah, it can get over, you can get, you can get inundated with stuff that's not relevant to you. Whereas what you're saying would be highly relevant and highly useful and highly beneficial. Yeah, but it's a risk. I mean, that's why sort of, there's a lot of innovative ways of doing that. Tesla's an example of people that basically don't do marketing. They do marketing in a very, like, I think Elon hired a person who's just good at Twitter for running Tesla's Twitter account. No, right, right. I mean, that's exactly what you wanna be doing. You want to be constantly innovating in a- Right, there's an aspect of telling. I mean, I've definitely seen people doing great work where you're not talking about it. Like I would say that's actually a problem I have right now with QuantSight Labs. QuantSight Labs been doing amazing work, really excited about it, but we have not been talking about it enough. We haven't been- And there's different ways to talk about it. There's different ways to, there's different channels to which to communicate. There's also, like, I'll just throw some shade at companies I love. So for example, iRobot, I just had a conversation with them. They make Roombas. Sure. And they, I think I love, and they're incredible robots, but like every time they do like advertisement, not advertisement, but like marketing type stuff, it just looks so corporate. And to me, the incredible, maybe wrong in the case of iRobot, I don't know, but to me, when you're talking about engineering systems, it's really nice to show off the magic of the engineering and the software and all the geniuses behind this product and the tinkering and like the raw authenticity of what it takes to build that system versus the marketing people who want to have like pretty people like standing there all pretty with the robots like moving perfectly. So to me, there's some aspect. It's like speaking to the hackers. You have to throw some bones, some care towards the engineers, the developers, because there's some aspect, one, for the hiring, but two, there's an authenticity to that kind of communication that's really inspiring to the end user as well. Like if they know that brilliant people, the best in the world are working at your company, they start to believe that that product that you're creating is really good. It's interesting. Because your initial reaction would be, wait, there's different users here. Why would you do that? My wife bought a Rumba, but she, and she loves developers, she loves me, but she doesn't care about that. Yeah, well, it's interesting what you said is actually the authenticity, because everyone has a friend or one knows people, there's word of mouth. I mean, if you- Word of mouth is so, so powerful. Yeah, exactly, that's interesting. Because I think it's a lack of that realization there's this halo effect that influences your general marketing. Interesting. For some stupid reason, I do have a platform and it seems that the reason I have a platform, many others like me, millions of others, is like the authenticity and like we get excited naturally about stuff. And like, I don't wanna get excited about that iRobot video, because it's boring, it's marketing, it's corporate, as opposed to, I wanted to do some fun, this is me, like a shout out to iRobot, is they're not letting me get into the robot. Yeah, well, there's an aspect of, they could be benefiting from a culture of modularity, like add-ons and like that could actually dramatically help. You've seen that over history, I mean, Apple is an example of a company like that, or the, like, I can see what your point is, is that you have something that needs to be, it needs to be adopted broadly, the concept needs to be adopted broadly. And if you wanna go beyond this one device, you need to engage this community. Yeah, and connecting to the open sources you said, I gotta ask you, you're a programmer, one of the most impactful programmers ever, you've led many programmers, you lead many programmers, what are some from a programmer perspective, what makes a good programmer? What makes a productive programmer? Is there a device you can give to be a great programmer this way? That's a great, great question. And there are times in my life, I'd probably answer this even better than I hoped maybe give an answer today, because I've thought about this numerous times, like right now I've spent on so much time recently hiring salespeople that- That your mind is a little bit- My mind is a little bit- On something else. On something else, but I reflected on the past, and also, you know, I have some really, the only way I can do this, I have some really great programmers that I work with, who lead the teams that they lead. And my goal is to inspire them and hopefully help them, encourage them and be, help them encourage with their teams. I would say there's a number of things, couple of things. One is curiosity. Like you, I think a programmer without curiosity is mundane. Like you'll lose interest, you don't do your best work. So it's sort of, it's an affect. It's sort of, are you, have some curiosity about things. I think two, don't try to do everything at once. Recognize that you're, you know, we're limited as humans. You're limited as a human. And each one of us are limited in different ways. You know, we all have our different strengths and skills. So it's adapting the art of programming to your skills. One of the things that always works is to limit what you're trying to solve, right? So if you're part of a team, usually maybe somebody else has put the architecture together and they've gotten given a portion for you, if you're young. If you're not part of a team, it's sort of breaking down the problem into smaller parts, is essential for you to make progress. It's very easy to take on a big project and try to do it all at once and you get lost and then you do it badly. And so thinking about, you know, very concretely what you're doing, defining the inputs and outputs, defining what you want to get done. Even just talking about that and like writing down before you write code, just what are you trying to accomplish? I mean, very specific about it really, really helps. I think using other people's work, right? Don't be afraid that somehow you're, like you should do it all. Like nobody does. Stand on the shoulders of giants. Stand on the shoulders of giants. And copy and paste from stack overflow. Copy and paste from stack overflow. It's like, but don't just copy and paste. It's particularly relevant in the era of codecs and the auto generated code, which is essentially I see as an indexing of stack overflow. Right, exactly. It's like. It's a search engine. It's a search engine over stack overflow basically. So it's not, I mean, we've had this for a while, but really you want to cut and paste, but not blindly. Like absolutely I've cut and paste to understand, but then you understand, oh, this is what this means. Oh, this is what it's doing. And understand as much as you can. So it's critical. That's where the curiosity comes in. If you're just blindly cutting and pasting, you're not going to understand. And so understand and then, you know, be sensitive to hype cycles, right? Every few, every few often there's always a, oh, test driven development is the answer. Oh, object oriented is the answer. Oh, like there's always an answer, you know, agile is the answer. Be cautious of jumping onto a hype cycle. Like likely there's signal, like there's a thing there that's actually valuable you can learn from, but it's almost certainly not the answer to everything you need. What lessons do you draw from you having created NumPy and SciPy, like in service of sort of answering the question of what it takes to be a great programmer and giving advice to people. How can you be the next person to create a SciPy? Yeah, so one is listen. To? Listen. To who? To people who have a problem, right? Which is everybody, right? But listen and listen to many. And then try to then do, like you're gonna have to do an experiment, you know, do fall down, don't be afraid to fall down. Don't be afraid. The first thing you do is probably gonna suck and that's okay, right? It's honestly, I think iteration is the key to innovation. And it's that, it's almost that psychological hesitation we have to just iterate. Like, yeah, we know it's not great, but next someone will be better. I mean, just keep learning and keep improving so it's an attitude. And then it doesn't take intense concentration, right? Good things don't happen just, it's not quite like TikTok or like Facebook, you know? You can't scroll your way to good programming, right? There are, you know, sincere like hours of deep, don't be afraid of the deep problem. Like often people will run away from something because, oh, I can't solve this. And you might be right, but give it an hour, give it a couple of hours and see. And, you know, just five minutes, not gonna give you that. Was it lonely when you were building SciPy and NumPy? Hugely, yeah, absolutely lonely in the sense of, you had to have an inner drive and that inner drive for me always comes from, I have to see that this is right in some angle. I have to believe it, that this is the right approach, the right thing to do. With SciPy, it was like, oh yeah, the world needs libraries and Python. Clearly, Python is popular enough with enough influential people to start and it needs more libraries. So that is a good in itself. So I'm gonna go do that good. So find a good, find a thing that you know is good and just work on it. So that has to happen and it is. And you kind of have to have enough realization of your mission to be okay with the naysayer or the fact that not everybody joins you at front. In fact, one thing I've talked to people a lot, I've seen a lot of projects come and some fail. Like not everything I've done has actually worked perfectly. I've tried a bunch of stuff that, okay, that didn't really work or this isn't working and why. But you see the patterns and one of the key things is you can't even know for six months. I say 18 months right now. If you're just starting a new project, you gotta give it a good 18 month run before you even know if the feedback's there. Like you're not gonna know in six months. You might have the perfect thing, but six months from now, it's still kind of still emerging. So give it time because you're dealing with humans and humans have an inertial energy that just doesn't change that quickly. So- Let me ask a silly question, but like you said, you're focused on the sales side of things currently, but back when you were actively programming maybe in the 90s, you talked about IDEs. What's your setup that you have that brings you joy? Keyboard, number of screens, Linux. I do still like to program some, it's not as much as I used to. I have two projects I'm super interested in, trying to find funding for them, trying to figure out some good teams for them, but I could talk about those. But what I, yeah, I'm an Emacs guy. Great, thank you. The superior editor, everybody. I've got, I don't often delete tweets, but one of the tweets I deleted when I said Emacs was better than them, and then the hate I got from them. It is. I was like, I'm walking away from this. I do too, I don't push it. I mean, I'm not. I'm just joking, of course. Yeah, exactly, it's kind of like, but people do take the editor seriously, right? I did as a joke. It's your life. It is, but there's something beautiful to me about Emacs, but for people that love them, there's something beautiful to them about that. I do use them for quick editing, like command line, if I say quick editing, I will still sometimes use it, but not much. Like it's simple, correct a single editor character. So when you were developing SciPy, you were using Emacs. Yep, SciPy and NumPy are all written in Emacs on a Linux box, and CVS, and then SVN, version control. Git came later. Like Git has, I love distributed branch stuff. I think Git is pretty complicated, but I love the concept. And also of course, GitHub is, and then GitLab make Git definitely consumable, but that came later. Did you ever touch Lisp at all? Like what were the emotional feelings about all the parentheses? Great question. So I find myself appreciating Lisp today much more than I did early. Cause when I came to programming, I knew programming, but I was a domain expert, right? And to me, the parentheses were in the way. It's like, wow, it's just all this, like it just gets in the way of my thinking about what I'm doing. So why would I have all these, right? That was my initial reaction to it. You know, now as I appreciate kind of the structure that kind of naturally maps to a logical thinking about a program, I can appreciate them, right? And why it's actually, you could create editors that make it not so problematic, right? Honestly. Yeah. I actually have a much more appreciation of Lisp and things like Clojure and there's Hy-Vee, which is a Python, you know, a Lisp that compiles the Python byte code. I think it's challenging. Like typically these languages are, you know, I even saw a whole data science programming system in Lisp that somebody created, which is, you know, cool. But again, it's the, I think it's the lack of recognition of the fact that there exists what I call occasional programmers. People are never going to be programmers for a living. They don't want to have all this cuteness in their head. They want just, you know, it's why basic, you know, Microsoft had the right idea with basic in terms of having that be the language of visual basic, the language of Excel and SQL Server. They should have converted that to Python 10 years ago, like world would be a better place if they had, but. There's also, there's a beauty and a magic to the history behind a language in Lisp, you know, some of the most interesting people in the history of computer science and artificial intelligence have used Lisp. So you feel. Well, it's back to that language. When you have a language, you can think in it. Yeah. And it helps you think about it. And it attracts certain kinds of people that think in a certain kind of way, and then that's there. Okay, so what about like small laptop with a tiny keyboard, or is there like three screens? You know, good question. I've never gotten into the big, many screens, to be honest. I mean, and maybe it's because in my head, I kind of just, I just swap between windows. Like partly because I guess I really can't process three screens at once anyway. Like I just am looking at one and I just flip, you know, I flip an application open. So where it's really helpful is actually when I'm trying to, you know, here's data and I want to input it from here. Like this is the only time I really need another screen. So now because you're both developer, lead developers, but then there's also these businesses and there's sales people in your working with large companies. Operations people, hiring people. The whole thing. Which operating system is your favorite still at this point? So Linux was the early days. So yeah, I love Linux as a server side. And it was early days I had my own Linux desktop. I've been on Mac laptops for 10 years now. Yeah, this is what leadership looks like. You switched to Mac. Okay, great. Pretty much. I mean, just the fact that I had to do PowerPoints, I had to do presentations and, you know, plug-in. I just couldn't mess with plug-in in laptops who wouldn't project and yeah. So you mentioned so Quonset Labs and things like that. Can you give advice on how to hire great programmers and great people? Yeah, I would say produce an open source project. Yeah. Get people contributing to it and hire those people. Yeah. I mean, you're doing it sort of, you might be perhaps a little biased, but that's probably 100% really good advice. I find it hard to hire. I still find it hard to hire. Like in terms of, I don't think, it's not hard to hire if I've worked with somebody for a couple of weeks, but an hour or two of interviews, I have no idea. So that instinct, that radar of knowing if you're good or not, you found that you're still not able to really. It's really hard. I mean, the resume can help, but again, the resume is like a presentation of the things they want you to see, not the reality of, and there's also, you know, you have to understand what you're hiring for. There are different stages and different kinds of skills. And so it isn't just a, one of the things I talk a lot about internally at my company is that the whole idea of measuring ourselves against a unit, a single axis is flawed. Cause we're not, it's a multi-dimensional space. And how do you order a multi-dimensional space? There isn't one ordering. So this whole idea, you immediately have projected into a thing and you're talking about hiring or best or worst or better or not better. So what is the thing you're actually needing? And you can hire for that. There is such a thing, generally, I really value people who have the affect, the care about open source. Like so in some cases, they're, they're thinner to open source is simply a kind of a filter of an affect. However, I have found this interesting dichotomy between open source contributors and product creation. There's, I don't know if it's fully true, but there does seem to be the more, the more experienced, the more affect somebody has in open source community, the less ability to actually produce product that they have. But you, but you have one. And the opposite is kind of true too. The more product focused are, I find a lot of people, I've talked to a lot of people who produce really great products and they have a, they're looking over the open source communities, kind of wanting to participate and play, but they played here and they do a great job here. And then they don't necessarily have some of the same, now I don't think that, I don't think that's entirely necessary. I think part of it is cultural, how that's, how they've emerged. Cause one of the things that open source communities often lack is great product management, like some product management energy that. That's brilliant. But you want both of those energies in a same place together. Yes, you really do. And so it's a lot of it's creating these teams of people that have these needed skills and attributes that are hard. And so, so one of the big things I look for is somebody that fundamentally recognize their need to learn. Like one of the values that we have and all of the things we do is learning. Like if somebody thinks they know it all, they're going to struggle. And some of that is just, there's more basic things like humility, just being humble in the face of all the things you don't know. And that's like step one of learning. That's step one of learning, right? And, you know, I've spent a lot of time learning, right? Other people spend a lot more time, but I've spent a lot of time learning. I went, you know, my whole goal was to get a PhD because I love school and I wanted to be a scientist. And then what I found is what's been written about elsewhere as well as the more I learned, the more I didn't know, the more I realized, man, I know about this, but this is such a tiny thing in the global scope of what I might want to know about. So I need to be listening a whole lot better than, than I am just talking. That's changed a little bit. Actually, my wife says that I used to be a better listener. Now that I have, I'm so full of all these ideas I want to do, she kind of says, you got to give people time to talk. So you've succeeded on multiple dimensions. So one is the tenure track faculty. The other is just creating all these products then building up the businesses, then working with businesses. Do you have advice for young people today in high school, in college of how to live a life as nonlinear and as successful as yours, a life that could be, they could be proud of? Well, that's a super compliment. I'm humbled by that actually. I would say a life that can be proud of, honestly, one thing that I've said to people is, first, find people you love and care about them. Like family matters to me a lot and family means people you love and have committed to. Right? So it's can be whatever you mean by that, but it's, you need to have a foundation. So find people you love and want to commit to and do that. Cause it anchors you in a way that nothing else can. Right? And then you find other things. And then kind of from out there, you find other kinds of things you can commit to, whether it's ideas or people or groups of people. So, especially in high school, I would say don't settle on what you think you know. Like give yourself 10 years to think about the world. Like there's, I see a lot of high school students who seem to know everything already. I think I did too. I think it's maybe natural, but recognize that the things you care about, you might change your perspective over time. I certainly have over time as under, I was really passionate about one specific thing and that was kind of softened. I was a big, I didn't like the federal reserve, right? And there's still, we can have a longer conversation about monetary policy and finances, but I'm a little more nuanced in my perspective at this point. But that's one area where you learn about something, go, I want to attack it. You know, build, don't destroy, like build. Like so often the tendency is to not like something, they want to go attack it, build something, build something to replace it, build up, attract people to your new thing. You'll get far more, be far better, right? You don't need to destroy something to build something else. So that's, I guess generally. And then, definitely like curiosity, follow your curiosity and let it, don't just follow the money. And all of that, like you said, is grounded in family, friendship and ultimately love. Yes. Which is a great way to end it. Travis, you're one of the most impactful people in the engineering and the computer science in the human world. So I truly appreciate everything you've done and I really appreciate that you would spend your valuable time with me. It was an honor. It was a real pleasure for me. I appreciate that. Thanks for listening to this conversation with Travis Olyphant. To support this podcast, please check out our sponsors in the description. And now, let me leave you with something that in the programming world is called Hodgson's Law. Every sufficiently advanced Lisp application will eventually be re-implemented in Python. Thank you for listening and hope to see you next time. Are there any words to this 54- best intervene Options are go to